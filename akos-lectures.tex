\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{minted}
\usepackage[normalem]{ulem}

% Цвета для гиперссылок
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000FF} % цвет гиперссылок

\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\newcommand{\tac}{\textasciicircum}
\newcommand{\tat}{\textasciitilde}
\newcommand{\tbs}{\textbackslash}
\newcommand{\ci}{\mintinline{c}}
\newcommand{\cl}{\mint{c}}
\newcommand{\bash}{\mintinline{c}}

\title{\textbf{Лекции по АКОСу}}
\begin{document}

\maketitle

\section{07.04.16}
\paragraph{Микроядро/монолитное ядро}
Ядро -- код, который загружается загрузчиком в момент запуска компьютера и работает в привилегированном режиме.
\begin{enumerate}
\item Монолитное ядро. Весь код ядра компилируется в один файл, в нём должны быть возможности для обработки всех возможных событий, и работает в привилегированном режиме.
\item Расширяемое ядро. Механизм модулей ядра, которые можно подгружать по требованию с внешнего устройства в оперативную память.

insmod *.ko (install module; kernel object)
Этот файл, написанный обычно на C или ассемблере, компилируется в объектный файл, после к нему добавляется метаинформация, позволяющая установить модуль в ядро.

modprobe имя\_модуля ищет файл .ko в каталоге /lib/modules/linux-.../. Есть ещё файл modules.map, который содержит места поиска модулей, а также их зависимости (например, чтобы подгрузить модуль для работы с жёстким диском, надо подгрузить модуль SATA-интерфейса и прочее)

lsmod выдаёт список уже подгруженных модулей.

Ядро должно обязательно иметь драйверы для работы с шинами (PCI Express, остальные не нужны), модуль прерываний, прочее -- это содержится в монолитном ядре. На это навешиваются модули, работающие с близкими к процессору шинами, потом ещё... Модули зависят друг от друга, и поэтому вряд ли можно так просто удалить модуль, близкий к ядру (рис. 1).

Модуль состоит из функции инициализации и убиения. Остальное -- опционально.

\ci|module_init(...)| -- модуль может принимать параметры (см. /etc/modules).
В список модулей нужно воткнуть заглушку stub, ибо компилятор добавляет ещё свои параметры.
\ci|module_destroy(...)|
Первую вызывает insmod, модуль может и не установиться и вернуть ошибку.

Вторую вызывает ядро и обязательно убивает модуль. 

Пользователь может командой rmmod попросить ядро убить модуль, и ядро в любое удобное ему время может удалить модуль, а может и не удалить (например, есть зависимости). rmmod -f форсирует, но ответственность за последствия возлагается на пользователя (надо гарантировать, что модулем никто не пользуется).

Плюсы монолитного/расширяемого ядра:
\begin{enumerate}
\itemРаботает быстрее (не надо часто переключать контекст при переходе от режима пользователя в привилегированный режим).
\itemМало косвенной адресации.
\end{enumerate}
Минусы:
\begin{enumerate}
\itemСложно писать.
\itemОшибка в модуле приводит к краху всего ядра. Оно может даже так сломаться, что не скажет об этом ( 
\itemМожно подсунуть заведомо неправильно работающий модуль (например, затирающий всю виртуальную память ноликами).
\end{enumerate}
Ядро может находиться в нормальном состоянии (всё хорошо). Оно может ещё совершать действия, но не может дальше продолжать работу в нормальном режиме. Тогда оно устраивает kernel panic (BSOD в Windows). Оно выводит информацию об ошибке и дамп памяти на экран и требует перезагрузки.
\item Микроядро.
Содержит механизм запуска/остановки процессов, базовые механизмы работы с системной шиной. Всё остальное реализовано как пользовательские процессы, работающие в пользовательском режиме в своей виртуальной памяти.
Есть подозрение, что Windows имеет микроядро. gnu hurd имеет.
Плюсы:
\begin{enumerate}
\item сложно сломать
\item проще программировать
\end{enumerate}
Минусы:
\begin{enumerate}
\item Медленное: очередь событий, которыми общаются процессы (а их очень много), становится узким местом.
\item Необходимость частого переключения контекста.
\end{enumerate}

\end{enumerate}

\paragraph{Процессы}
\begin{enumerate}
\item Данные процеса
\item Права на ресурсы
\end{enumerate}
Контекст процесса:
\begin{enumerate}
\item Аппаратная составляющая: регистры, таблица страниц, границы сегментов, ...
\item Пользовательская составляющая: данные процесса: код, переменные, ... 
\item Системная составляющая: 
\begin{enumerate}
\item информация о процессе
\item хранящаяся в операционной системе, не необходимая для выполнения кода: идентификатор процесса (pid), pid родителя (ppid), uid, gid, euid, egid (идентификатор процесса, группы, эффективные идентификаторы, т. е. те, которые процесс приобрёл, а не те, которые были вначале), таблица открытых файлов процесса, корень для процесса (операция chroot говорит, что нужно считать каталогом / какой-то другой каталог), терминал, к которому привязан процесс, группа процесса (pgid; чтобы процесс мог использовать терминал на чтение, нужно, чтобы его pgid совпадал с pid), идентификатор сессии sesid (задаёт иерархию процессов; при завершении прооцесса, у которого sesid совпадает с pid, ядро убивает все процессы с тем же sesid; поэтому надо позаботиться, чтобы демон был главным в своей сессии, иначе его могут принудительно убить), cgroup (ограничения ресурсов для всей группы процесса), квант времени, выделяемый ОС процессу для выполнения его задач до следующего переключения контекста; если квант времени большой, то программа может долго считать, например, что-либо, но нажатие кнопки быстро не обработается; при сборке ядро может быть оптимизировано под десктоп, сервер, систему ввода-вывода), ghbjhbntn (nice; меняется утилитой renice; чем меньше -- тем важнее; 1. Динамический приоритет, назначаемый ядром. Новый процесс должен иметь наибольший приоритет, а процесс, дольше всех простоявший в очереди -- наименьший.
2. Статический приоритет, назначаемый ядром. Привилегированные процессы, работающие в адресном пространстве ядра, имеют малый приоритет, чтобы их не задавили пользовательские процессы.
init имеет приоритет 1, т.к. он отслеживает ситуацию, когда с другими процессами что-то не так.
3. Статический приоритет, назначаемый пользователем root (pid 0).
4. Статический приоритет, назначаемый пользователем. Обычный пользователь не может уменьшить приоритет больше, чем на какое-то зафиксированное число.

Набор ограничений на процесс (как много файлов можно открыть, какой предельный размер пайпа может быть использован, какой размер виртуальной памяти может быть выделен, ...)
\begin{minted}{bash}
ulimit -a 
set_limits
apropos 2 limits
\end{minted}

Есть жёсткое ограничение, которое нельзя менять, есть мягкое ограничение, которое можно изменить. Если изменить до жёсткого, больше менять нельзя.

Сигнальная маска, очередь сигналов, список подключённых IPC-объектов. 
Состояние процесса: рис. 2.
exit\_status

Если у процесса убили отца, то ему нужен новый. Ядро назначает отцом процесс init. init смотрит, какая у процесса сессия: хорошая или плохая, и если плохая, тут же убивает его.
Состояние зомби: процесс завершил работу, но ещё никто не узнал, как. Обычно для этого отец должен вызвать wait() или waitpid(), при этом запись в таблице процессов удалится.

Терминал -- абстракция. Поддерживает посимвольный ввод и вывод. Считается, что буквы могут возникать не чаще, чем раз в сколько-то миллисекунд. /dev/tty ныне ассоциирован с клавиатурой и монитором, но раньше им могли быть разные экзотические устройства вроде принтера, модема, COM-порта. С каждым процессом ассоциирован терминал, если это процесс -- не демон.

\end{enumerate}
\end{enumerate}

\section{14.04.16}
\paragraph{Системные вызовы для манипуляции процесса}
clone. Через clone реализованы fork, vfork (для классического процесса), pthread\_create (для потока).

С каждым процессом связаны иерархические таблицы адресов в оперативной памяти (таблица страниц/каталогов). fork копирует всю память программы как она есть. Различие заключается лишь в вершине стека или регистре, т.к. таким образом родитель получает pid созданного процесса, а сын -- 0. 

Для процесса код остаётся старый, данные и стек копируется. Для потока код и данные остаются старыми, стек копируется. Для реализации отложенного копирования (см. copy-on-write) страницы памяти помечаются как read-only. При первом же обращении на запись происходит прерывание page fault, по которому ядро одному процессу делает копию страницы и меняет согласно этому запись в таблице страниц, а другому отдаёт старую страницу, снимая флаг RO. Новому процессу создаётся новая системная часть контекста (pid, проч.).

Поток.
Некоторые ОС считают, что процесс есть набор потоков: есть главный и побочные, которые выполняют работу в пределах этого процесса. В идеале потоки загружаются в процессор (особенно многоядерный) одновременно, обрабатывают одни и те же данные, избегая тем самым ошибок кеша. Плохая идея -- заставлять потоки запускаться на разных процессорах или обрабатывать совсем разные данные.

\paragraph{execve}
Подмена тела процесса. Тело процесса-родителя блокируется, пока в сыне не будет сделан exec. 

\mint{c}|int execve(const char* path, char** argv, char** env);|
ОС должна будет выбросить всю виртуальную память.
Открытые файлы сохраняются. Чтобы их позакрывать автоматически, нужно при открытии пометить их closeexec. То есть, работа с ними ложится на программиста.

В ядре ОС есть загрузчик (не путать с загрузчиком ОС). Он читает первые байты файла.,
(\#!путь означает, что содержимое файла нужно направить в stdin, а в качестве программы запустить путь; например, \#!/bin/sh.

.ELF -- формат исполняемых файлов linux.

wine позволяет исполнять MZ (виндовые файлы) под linux, компиляция ядра с ключами прозволяет нативно исполнять файлы для FreeBSD. 

Подгрузка кода в память производится лениво (по требованию). nmap позволяет динамически подгружать код самой исполнимой программой (для этого есть системный вызов). 

Права на исполнение проверяются при exec. suid бит позволяет при некоторых обстоятельствах получить euid'ом идентификатор владельца файла (чтобы все могли исполнять данный файл с правами его создателя). Так можно повысить права до суперпользователя. Поэтому все современные unix'ы запрещают это делать из соображений безопасности. 


Процесс можно ждать. wait, waitpid, wait4 (последний не входит в POSIX). Позволяет узнать, что случилось с процессом, например, почему он умер. Можно wait только сыновей, waitpid -- всех, на которых есть права. Возвращают переменную int status, в которой содержится код возврата и другая информация.

Нормально процесс завершается вызовом \_exit(int) (не путать с exit(int), которая делает ещё несколько вещей), а ненормально -- abort (убивает и делает дамп памяти).

Процесс можно убить сигналом вызовом kill.

\paragraph{Блочные устройства}
Устройства, чтение и запись в которые осуществляется только блоками, не меньше.

Примеры: HDD, SSD, cd-rom, dvd-rom, blu-ray, ..., /dev/nvram (представляет участок оперативной памяти как блочное устройство), /dev/loopbackdevice, ...

На всех блочных устройствах может быть фалйовая система.

На HDD блоки определяются сектором, цилиндром и поверхностью. Этим всем управляет драйвер, поэтому ОС видит HDD просто как линейную последовательность блоков.

Обычно медленны. Решение: 
кеширование, 
много устройств как одно (повышает надёжность, скорость или одновременно),
RAID или LVM.
\paragraph{RAID}
Уровни RAID:

RAID 0 -- несколько блочных устройств одинакового размера цепляются друг за другом (скорость, нет надёжности: если ломается один диск, не просто теряется кусок данных размером в диск, а появляются пропуски).

RAID 1 -- одна и та же информация пишется на все диски (надёжность: если выжил хоть один диск, информация сохранилась). Если два диска содержат разную информацию, то можно либо ругаться, чтобы какой-то из них человек выбрал как нужное.

RAID 2 -- данные распределены так, что для каждого блока вычисляется код Хэмминга, исправляющий ошибки. Почти никогда не используется.

RAID 3 -- хранится контрольная сумма. Если грохаются два диска, всё плохо. Чем больше дисков, тем сложнее считать хеши. Диск, на котором хранятся контрольные суммы, быстрее изнашивается и, т. к. к нему постоянно обращаются, становится узким местом.

RAID 5 -- контрольная сумма мигрирует по кругу по всем дискам.

RAID 6 -- две размазанные по всем дискам контрольные суммы. Позволяет грохнуть два диска.

Остальные -- комбинации данных RAID'ов.

RAID бывают аппаратные и программные. Аппаратные лучше и быстрей, но если сдохнет контроллер RAID, то всё грохнется, т. к. никто не будет знать, в каком порядке читать. 

Протокол iSCSI позволяет делать RAID-массивы на разных машинах в сети.

Позволяет отключать отдельные устройства, не ломая всё.

Например, у вас есть база данных, которая сильно изменяется в объёме время от времени. Чтобы не использовать лишние пустые диски, можно их отключать.

volume group -- хранит аппаратные координаты данных на дисках.

logical volume -- задаёт координаты данных поверх дисков, входящих в volume group. group может иметь несколько logical volume, Файловая система создаётся поверх logical volume.

\paragraph{Загрузка ОС}
Всегда происходит с блочного устройства. 
\begin{enumerate}
\item PXE-загрузка. Образ загрузчика присылается по специальному протоколу по сети, он размещается в оперативной памяти. Обычно этот сетевой загрузчик запускает syslinux.
\item syslinux -- специальный загрузчик для блочных устройств.
Позволяет запускать себя с flash, cdrom или из сети.
\item Блочные устройства типа HDD. Intel или AMD  -- MBR (устарело; не позволяет создать таблицу разделов больше 1 Тб) или GPT. Явно прописано, где должен находиться загрузчик. 
\end{enumerate}

\section{21.04.16}
\paragraph{Таблицы разделов на жёстком диске}
Виртуальная сущность. Нужны для изоляции разных систем на жёстом диске, и вообще для изоляции данных.

В intel архитектуре:

\paragraph{MBR (Master Boot Record)}
512 байт по адресу (0,0,0)  -- загрузчик первой ступени.

Далее идёт описание четырёх разделов. Раздел имеет тип и загрузочную метку. Предполагается, что эта метка стоит только напротив одного раздела. Помечает, какой из разделов содержит загрузчик ОС (второй стадии).

Extended partition содержит свою собственную таблицу разделов, в которой можно записать виртуальные разделы.

Одновременно можно ставить не более 4 ОС. Загрузчики на первичных разделах могут говорить, где на extended partition лежит, собственно, ОС.

Утилиты для манипуляции с таблицами разделов: fdisk, cfdisk, sfdisk.

\mintinline{bash}|dd if=/dev/zero of=/dev/sdx|  -- затереть таблицу разделов

Таблица разделов может быть защищённой, тогда просто так перезаписать нельзя.

MBR считается устаревшей, т.к. с помощью неё нельзя создавать разделы более 3 ТБ.

\paragraph{GPT (Guid Partition Table)}
Сначала идёт MBR, на ней написано, что она защищена, после первичная запись GPT, в конце HDD идёт вторичная запись GPT.

GPT -- список из 128 разделов. В конце хранится копия.

GPT использует LBA (Linear Block именование) -- линейный способ именования данных на диске, не вдающийся в подробности типа номера секторов.

Адресация двумя цифрами -- начало и конец.

Нет понятия загрузочной записи, но вместо этого первый раздел обычно считается загрузочным, имеет ФС fat32 и содержит в себе загрузочные записи UEFI BIOS'а.

Ещё есть ключ, которым можно подписать раздел (защита от злобных вирусов, которые могут перезаписать загрузчик).

Вирус помечает несколько блоков как сбойные, хранит там себя, переписывает загрузчик, чтобы он грузил сбойные блоки, и сам загружает ОС после себя; проверка блоков на сбойность осуществляется на уровне драйвера ОС, поэтому она не перезапишет вирус, а он будет в памяти ещё до загрузки ОС).

\paragraph{UEFI}
Первоначально был BIOS (Basic Input-Output System).

UEFI(Unified Extended Firmware Interface) -- БИОС, который как бы ОС, имеет свой раздел, куда складываются (обычно) загрузчики первой стадии, может лежать драйвер файловой системы, есть даже shell и прочее).

Intel, Sun, некоторые ARM теперь с UEFI. Он слишком сложный.

Задумывался как универсальный интерфейс для загрузки любых ОС в любом режиме.

\paragraph{Загрузка компьютера (на примере семейства UNIX)}
\begin{enumerate}
\item "Создание планеты".
POST -- Power-On Self Test. Зависит от железа.

Даже нажатие на \sout{большую красную} кнопку может быть по-разному (IPMI-интерфейс; железячка, управляющая компьютером по сети; может, например, включать/выключать компьютер, выбирать устройства, которые будут включаться, проч.). Например, по сети.
В данном случае POST выполняет микросхема.

Между прочим, то, что все лампочки вначале горят, есть проявление POST. Когда устройство проходит проверку, лампочки гаснут. Мимоходом составляется таблица подключенных устройств.

\item "Создание животного мира"

Допустим, мы хотим на Intel Core i7 запустить 16-битный DOS.

Выполняется POST. Заполняются вектора прерываний, прочее. Первые 512 байт диска копируются в память и им передаётся управление. 

Потом ищется загрузчик второй стадии. Он уже может переключить процессор в 16-битный режим. Загрузчик второй стадии обычно жирнее и умеет, например, в файловые системы и модули ядра.

PowerPC -- yaboot, slilo -- Sun, lilo, syslinux, grub2 -- intel.

Grub2 поддерживает chainload, то есть загрузку загрузчиков ОС. То есть, им можно грузить всякие винды, которые грузятся только родными загрузчиками.

Старые BIOS не умели загружить загрузчик, который был дальше, чем 1 ГБ от начала. Совет: размещайте их в начале диска.

initramfs -- файловая система, которая размещается в оперативной памяти в момент загрузки. Там обычно лежат все нужные драйверы и модули ядра, которые нужны для работы компьютера.

\item "Создание человека"
Загрузка самой ОС.
\begin{enumerate}
\item Разворачивание виртуальной памяти.
\item Переформирование таблицы работы с внешними устройствами так, как хочется ей. 
\item Монтирование корня. Если был initramfs, то в качестве корня выступает кусок оперативной памяти.
\item Загрузка драйверов.
\item Организация буферов ввода/вывода. У ядра есть буфер операций, ядро рассортировывает это по буферам драйверов, а драйвер формирует, собственно, запрос и отправляет в буфер устройства.
\item Разворачивание инфраструктуры для запуска процессов. Заводится таблица процессов. Само ядро -- нулевая запись.
kexec позволяет заменить образ ядра в оперативной памяти по файлу на диске. Увы, версию ядра поменять не получится.
\end{enumerate}
\item "Создание общества"

Запуск init. Ядро, собственно, может запускать любую программу, которую ему передали в параметре ядра init=.

Если прописать /bin/bash, то можно получить root-привилегии на локальной машине (если сможете прописать параметры ядра при загрузке).

sysv-init -- init, который использовался уже лет сорок, и всех всё устраивало. Когда linux стал десктопной ОС, потребовалась изоляция процессов и прочее. Теперь есть systemd.

Если надоело жить в chroot, можно сделать 
\begin{minted}{bash}
chroot
exec init 
\end{minted}
/etc/inittab содержит информацию о том, как настроить терминалы и организовать весь дальнейший мир.

Кстати, systemd тоже вначале есть обычный init, которму подменяют тело.

Уровни:

0 -- выключение

1 -- single user mode

2 -- предопределено пользователем

3 -- без графической оболочки

4 -- ?

5 -- с графической оболочкой

6 -- перезагрузка

В /etc/rc.d/ или /etc/init.d/ лежит куча shell-скриптов, которые запускают всё, нужное для runlevel. Часть скриптов запускает, часть скриптов останавливает.
/etc/init.d/ssh stop -- останавливает процесс ssh

systemd же совмещён с DBUS (сообщения типа "давайте примонтируем флешку, которую Вы только что воткнули"), одновременно запускает cgroups (ограничивает общение того, что запускается на разных терминалах, например, один терминал не может прочитать открытую другим флешку), содержит udev (обнаруживает устройства в real-time, вроде флешки, которую Вы только что воткнули) и специфичен для linux.


\end{enumerate}

\end{document}
