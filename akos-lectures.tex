\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{lmodern}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{minted}
\usepackage[normalem]{ulem}

% Цвета для гиперссылок
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000FF} % цвет гиперссылок

\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\newcommand{\tac}{\textasciicircum}
\newcommand{\tat}{\textasciitilde}
\newcommand{\tbs}{\textbackslash}
\newcommand{\ci}{\mintinline{c}}
\newcommand{\cl}{\mint{c}}
\newcommand{\bash}{\mintinline{c}}

\emergencystretch=10pt

\author{wiki-fan}
\title{\textbf{Лекции по АКОСу}}
\begin{document}

\maketitle

\section{07.04.16}
\paragraph{Микроядро/монолитное ядро}
Ядро -- код, который загружается загрузчиком в момент запуска компьютера и работает в привилегированном режиме.
\begin{enumerate}
\item Монолитное ядро. Весь код ядра компилируется в один файл, в нём должны быть возможности для обработки всех возможных событий, и работает в привилегированном режиме.
\item Расширяемое ядро. Механизм модулей ядра, которые можно подгружать по требованию с внешнего устройства в оперативную память.

insmod *.ko (install module; kernel object)
Этот файл, написанный обычно на C или ассемблере, компилируется в объектный файл, после к нему добавляется метаинформация, позволяющая установить модуль в ядро.

modprobe имя\_модуля ищет файл .ko в каталоге /lib/modules/linux-.../. Есть ещё файл modules.map, который содержит места поиска модулей, а также их зависимости (например, чтобы подгрузить модуль для работы с жёстким диском, надо подгрузить модуль SATA-интерфейса и прочее)

lsmod выдаёт список уже подгруженных модулей.

Ядро должно обязательно иметь драйверы для работы с шинами (PCI Express, остальные не нужны), модуль прерываний, прочее -- это содержится в монолитном ядре. На это навешиваются модули, работающие с близкими к процессору шинами, потом ещё... Модули зависят друг от друга, и поэтому вряд ли можно так просто удалить модуль, близкий к ядру (рис. 1).

Модуль состоит из функции инициализации и убиения. Остальное -- опционально.

\ci|module_init(...)| -- модуль может принимать параметры (см. /etc/modules).
В список модулей нужно воткнуть заглушку stub, ибо компилятор добавляет ещё свои параметры.
\ci|module_destroy(...)|
Первую вызывает insmod, модуль может и не установиться и вернуть ошибку.

Вторую вызывает ядро и обязательно убивает модуль. 

Пользователь может командой rmmod попросить ядро убить модуль, и ядро в любое удобное ему время может удалить модуль, а может и не удалить (например, есть зависимости). rmmod -f форсирует, но ответственность за последствия возлагается на пользователя (надо гарантировать, что модулем никто не пользуется).

Плюсы монолитного/расширяемого ядра:
\begin{enumerate}
\itemРаботает быстрее (не надо часто переключать контекст при переходе от режима пользователя в привилегированный режим).
\itemМало косвенной адресации.
\end{enumerate}
Минусы:
\begin{enumerate}
\itemСложно писать.
\itemОшибка в модуле приводит к краху всего ядра. Оно может даже так сломаться, что не скажет об этом (хорошо, если оно хотя бы упадёт в kernel panic).
\itemМожно подсунуть заведомо неправильно работающий модуль (например, затирающий всю виртуальную память ноликами).
\end{enumerate}
Ядро может находиться в нормальном состоянии (всё хорошо). Оно может ещё совершать действия, но не может дальше продолжать работу в нормальном режиме. Тогда оно устраивает kernel panic (BSOD в Windows). Оно выводит информацию об ошибке и дамп памяти на экран и требует перезагрузки.
\item Микроядро.
Содержит механизм запуска/остановки процессов, базовые механизмы работы с системной шиной. Всё остальное реализовано как пользовательские процессы, работающие в пользовательском режиме в своей виртуальной памяти.
Есть подозрение, что Windows имеет микроядро. gnu hurd имеет.
Плюсы:
\begin{enumerate}
\item сложно сломать
\item проще программировать
\end{enumerate}
Минусы:
\begin{enumerate}
\item Медленное: очередь событий, которыми общаются процессы (а их очень много), становится узким местом.
\item Необходимость частого переключения контекста.
\end{enumerate}

\end{enumerate}

\paragraph{Процессы}
\begin{enumerate}
\item Данные процеса
\item Права на ресурсы
\end{enumerate}
Контекст процесса:
\begin{enumerate}
\item Аппаратная составляющая: регистры, таблица страниц, границы сегментов, ...
\item Пользовательская составляющая: данные процесса: код, переменные, ... 
\item Системная составляющая: 
\begin{enumerate}
\item информация о процессе
\item хранящаяся в операционной системе, не необходимая для выполнения кода: 
\begin{itemize}
\item pid -- идентификатор процесса
\item ppid -- pid родителя
\item uid -- идентификатор процесса
\item gid -- идентификатор группы
\item euid
\item egid -- эффективные идентификаторы, т. е. те, которые процесс приобрёл, а не те, которые были вначале
\item таблица открытых файлов процесса, корень для процесса (операция chroot говорит, что нужно считать каталогом / какой-то другой каталог)
\item терминал, к которому привязан процесс
\item группа процесса (pgid; чтобы процесс мог использовать терминал на чтение, нужно, чтобы его pgid совпадал с pid)
\item идентификатор сессии sesid (задаёт иерархию процессов; при завершении прооцесса, у которого sesid совпадает с pid, ядро убивает все процессы с тем же sesid; поэтому надо позаботиться, чтобы демон был главным в своей сессии, иначе его могут принудительно убить)
\item cgroup (ограничения ресурсов для всей группы процесса)
\item квант времени, выделяемый ОС процессу для выполнения его задач до следующего переключения контекста; если квант времени большой, то программа может долго считать, например, что-либо, но нажатие кнопки быстро не обработается; при сборке ядро может быть оптимизировано под десктоп, сервер, систему ввода-вывода)
\item приоритет nice; меняется утилитой renice; чем меньше -- тем важнее: 
\begin{enumerate}
 \item Динамический приоритет, назначаемый ядром. Новый процесс должен иметь наибольший приоритет, а процесс, дольше всех простоявший в очереди -- наименьший.
 \item Статический приоритет, назначаемый ядром. Привилегированные процессы, работающие в адресном пространстве ядра, имеют малый приоритет, чтобы их не задавили пользовательские процессы. init имеет приоритет 1, т.к. он отслеживает ситуацию, когда с другими процессами что-то не так.
 \item Статический приоритет, назначаемый пользователем root (pid 0).
 \item Статический приоритет, назначаемый пользователем. Обычный пользователь не может уменьшить приоритет больше, чем на какое-то зафиксированное число.
\end{enumerate}
\item набор ограничений на процесс (как много файлов можно открыть, какой предельный размер пайпа может быть использован, какой размер виртуальной памяти может быть выделен, ...)

\begin{minted}{bash}
ulimit -a 
set_limits
apropos 2 limits
\end{minted}

Есть жёсткое ограничение, которое нельзя менять, есть мягкое ограничение, которое можно изменить. Если изменить до жёсткого, больше менять нельзя.

\item сигнальная маска
\item очередь сигналов
\item список подключённых IPC-объектов
\end{itemize}
\end{enumerate}
\end{enumerate}
Состояние процесса: рис. 2.
exit\_status

Если у процесса убили отца, то ему нужен новый. Ядро назначает отцом процесс init. init смотрит, какая у процесса сессия: хорошая или плохая, и если плохая, тут же убивает его.
Состояние зомби: процесс завершил работу, но ещё никто не узнал, как. Обычно для этого отец должен вызвать wait() или waitpid(), при этом запись в таблице процессов удалится.

Терминал -- абстракция. Поддерживает посимвольный ввод и вывод. Считается, что буквы могут возникать не чаще, чем раз в сколько-то миллисекунд. /dev/tty ныне ассоциирован с клавиатурой и монитором, но раньше им могли быть разные экзотические устройства вроде принтера, модема, COM-порта. С каждым процессом ассоциирован терминал, если это процесс -- не демон.


\section{14.04.16}
\paragraph{Системные вызовы для манипуляции процесса}
clone. Через clone реализованы fork, vfork (для классического процесса), pthread\_create (для потока).

С каждым процессом связаны иерархические таблицы адресов в оперативной памяти (таблица страниц/каталогов). fork копирует всю память программы как она есть. Различие заключается лишь в вершине стека или регистре, т.к. таким образом родитель получает pid созданного процесса, а сын -- 0. 

Для процесса код остаётся старый, данные и стек копируется. Для потока код и данные остаются старыми, стек копируется. Для реализации отложенного копирования (см. copy-on-write) страницы памяти помечаются как read-only. При первом же обращении на запись происходит прерывание page fault, по которому ядро одному процессу делает копию страницы и меняет согласно этому запись в таблице страниц, а другому отдаёт старую страницу, снимая флаг RO. Новому процессу создаётся новая системная часть контекста (pid, проч.).

Поток.
Некоторые ОС считают, что процесс есть набор потоков: есть главный и побочные, которые выполняют работу в пределах этого процесса. В идеале потоки загружаются в процессор (особенно многоядерный) одновременно, обрабатывают одни и те же данные, избегая тем самым ошибок кеша. Плохая идея -- заставлять потоки запускаться на разных процессорах или обрабатывать совсем разные данные.

\paragraph{execve}
Подмена тела процесса. Тело процесса-родителя блокируется, пока в сыне не будет сделан exec. 

\mint{c}|int execve(const char* path, char** argv, char** env);|
ОС должна будет выбросить всю виртуальную память.
Открытые файлы сохраняются. Чтобы их позакрывать автоматически, нужно при открытии пометить их closeexec. То есть, работа с ними ложится на программиста.

В ядре ОС есть загрузчик (не путать с загрузчиком ОС). Он читает первые байты файла.,
(\#!путь означает, что содержимое файла нужно направить в stdin, а в качестве программы запустить путь; например, \#!/bin/sh.

.ELF -- формат исполняемых файлов linux.

wine позволяет исполнять MZ (виндовые файлы) под linux, компиляция ядра с ключами прозволяет нативно исполнять файлы для FreeBSD. 

Подгрузка кода в память производится лениво (по требованию). nmap позволяет динамически подгружать код самой исполнимой программой (для этого есть системный вызов). 

Права на исполнение проверяются при exec. suid бит позволяет при некоторых обстоятельствах получить euid'ом идентификатор владельца файла (чтобы все могли исполнять данный файл с правами его создателя). Так можно повысить права до суперпользователя. Поэтому все современные unix'ы запрещают это делать из соображений безопасности. 


Процесс можно ждать. wait, waitpid, wait4 (последний не входит в POSIX). Позволяет узнать, что случилось с процессом, например, почему он умер. Можно wait только сыновей, waitpid -- всех, на которых есть права. Возвращают переменную int status, в которой содержится код возврата и другая информация.

Нормально процесс завершается вызовом \_exit(int) (не путать с exit(int), которая делает ещё несколько вещей), а ненормально -- abort (убивает и делает дамп памяти).

Процесс можно убить сигналом вызовом kill.

\paragraph{Блочные устройства}
Устройства, чтение и запись в которые осуществляется только блоками, не меньше.

Примеры: HDD, SSD, cd-rom, dvd-rom, blu-ray, ..., /dev/nvram (представляет участок оперативной памяти как блочное устройство), /dev/loopbackdevice, ...

На всех блочных устройствах может быть фалйовая система.

На HDD блоки определяются сектором, цилиндром и поверхностью. Этим всем управляет драйвер, поэтому ОС видит HDD просто как линейную последовательность блоков.

Обычно медленны. Решение: 
кеширование, 
много устройств как одно (повышает надёжность, скорость или одновременно),
RAID или LVM.
\paragraph{RAID}
Уровни RAID:

RAID 0 -- несколько блочных устройств одинакового размера цепляются друг за другом (скорость, нет надёжности: если ломается один диск, не просто теряется кусок данных размером в диск, а появляются пропуски).

RAID 1 -- одна и та же информация пишется на все диски (надёжность: если выжил хоть один диск, информация сохранилась). Если два диска содержат разную информацию, то можно либо ругаться, чтобы какой-то из них человек выбрал как нужное.

RAID 2 -- данные распределены так, что для каждого блока вычисляется код Хэмминга, исправляющий ошибки. Почти никогда не используется.

RAID 3 -- хранится контрольная сумма. Если грохаются два диска, всё плохо. Чем больше дисков, тем сложнее считать хеши. Диск, на котором хранятся контрольные суммы, быстрее изнашивается и, т. к. к нему постоянно обращаются, становится узким местом.

RAID 5 -- контрольная сумма мигрирует по кругу по всем дискам.

RAID 6 -- две размазанные по всем дискам контрольные суммы. Позволяет грохнуть два диска.

Остальные -- комбинации данных RAID'ов.

RAID бывают аппаратные и программные. Аппаратные лучше и быстрей, но если сдохнет контроллер RAID, то всё грохнется, т. к. никто не будет знать, в каком порядке читать. 

Протокол iSCSI позволяет делать RAID-массивы на разных машинах в сети.

Позволяет отключать отдельные устройства, не ломая всё.

Например, у вас есть база данных, которая сильно изменяется в объёме время от времени. Чтобы не использовать лишние пустые диски, можно их отключать.

volume group -- хранит аппаратные координаты данных на дисках.

logical volume -- задаёт координаты данных поверх дисков, входящих в volume group. group может иметь несколько logical volume, Файловая система создаётся поверх logical volume.

\paragraph{Загрузка ОС}
Всегда происходит с блочного устройства. 
\begin{enumerate}
\item PXE-загрузка. Образ загрузчика присылается по специальному протоколу по сети, он размещается в оперативной памяти. Обычно этот сетевой загрузчик запускает syslinux.
\item syslinux -- специальный загрузчик для блочных устройств.
Позволяет запускать себя с flash, cdrom или из сети.
\item Блочные устройства типа HDD. Intel или AMD  -- MBR (устарело; не позволяет создать таблицу разделов больше 1 Тб) или GPT. Явно прописано, где должен находиться загрузчик. 
\end{enumerate}

\section{21.04.16}
\paragraph{Таблицы разделов на жёстком диске}
Виртуальная сущность. Нужны для изоляции разных систем на жёстом диске, и вообще для изоляции данных.

В intel архитектуре:

\paragraph{MBR (Master Boot Record)}
512 байт по адресу (0,0,0)  -- загрузчик первой ступени.

Далее идёт описание четырёх разделов. Раздел имеет тип и загрузочную метку. Предполагается, что эта метка стоит только напротив одного раздела. Помечает, какой из разделов содержит загрузчик ОС (второй стадии).

Extended partition содержит свою собственную таблицу разделов, в которой можно записать виртуальные разделы.

Одновременно можно ставить не более 4 ОС. Загрузчики на первичных разделах могут говорить, где на extended partition лежит, собственно, ОС.

Утилиты для манипуляции с таблицами разделов: fdisk, cfdisk, sfdisk.

\mintinline{bash}|dd if=/dev/zero of=/dev/sdx|  -- затереть таблицу разделов

Таблица разделов может быть защищённой, тогда просто так перезаписать нельзя.

MBR считается устаревшей, т.к. с помощью неё нельзя создавать разделы более 3 ТБ.

\paragraph{GPT (Guid Partition Table)}
Сначала идёт MBR, на ней написано, что она защищена, после первичная запись GPT, в конце HDD идёт вторичная запись GPT.

GPT -- список из 128 разделов. В конце хранится копия.

GPT использует LBA (Linear Block именование) -- линейный способ именования данных на диске, не вдающийся в подробности типа номера секторов.

Адресация двумя цифрами -- начало и конец.

Нет понятия загрузочной записи, но вместо этого первый раздел обычно считается загрузочным, имеет ФС fat32 и содержит в себе загрузочные записи UEFI BIOS'а.

Ещё есть ключ, которым можно подписать раздел (защита от злобных вирусов, которые могут перезаписать загрузчик).

Вирус помечает несколько блоков как сбойные, хранит там себя, переписывает загрузчик, чтобы он грузил сбойные блоки, и сам загружает ОС после себя; проверка блоков на сбойность осуществляется на уровне драйвера ОС, поэтому она не перезапишет вирус, а он будет в памяти ещё до загрузки ОС).

\paragraph{UEFI}
Первоначально был BIOS (Basic Input-Output System).

UEFI(Unified Extended Firmware Interface) -- БИОС, который как бы ОС, имеет свой раздел, куда складываются (обычно) загрузчики первой стадии, может лежать драйвер файловой системы, есть даже shell и прочее).

Intel, Sun, некоторые ARM теперь с UEFI. Он слишком сложный.

Задумывался как универсальный интерфейс для загрузки любых ОС в любом режиме.

\paragraph{Загрузка компьютера (на примере семейства UNIX)}
\begin{enumerate}
\item "Создание планеты".
POST -- Power-On Self Test. Зависит от железа.

Даже нажатие на \sout{большую красную} кнопку может быть по-разному (IPMI-интерфейс; железячка, управляющая компьютером по сети; может, например, включать/выключать компьютер, выбирать устройства, которые будут включаться, проч.). Например, по сети.
В данном случае POST выполняет микросхема.

Между прочим, то, что все лампочки вначале горят, есть проявление POST. Когда устройство проходит проверку, лампочки гаснут. Мимоходом составляется таблица подключенных устройств.

\item "Создание животного мира"

Допустим, мы хотим на Intel Core i7 запустить 16-битный DOS.

Выполняется POST. Заполняются вектора прерываний, прочее. Первые 512 байт диска копируются в память и им передаётся управление. 

Потом ищется загрузчик второй стадии. Он уже может переключить процессор в 16-битный режим. Загрузчик второй стадии обычно жирнее и умеет, например, в файловые системы и модули ядра.

PowerPC -- yaboot, slilo -- Sun, lilo, syslinux, grub2 -- intel.

Grub2 поддерживает chainload, то есть загрузку загрузчиков ОС. То есть, им можно грузить всякие винды, которые грузятся только родными загрузчиками.

Старые BIOS не умели загружить загрузчик, который был дальше, чем 1 ГБ от начала. Совет: размещайте их в начале диска.

initramfs -- файловая система, которая размещается в оперативной памяти в момент загрузки. Там обычно лежат все нужные драйверы и модули ядра, которые нужны для работы компьютера.

\item "Создание человека"
Загрузка самой ОС.
\begin{enumerate}
\item Разворачивание виртуальной памяти.
\item Переформирование таблицы работы с внешними устройствами так, как хочется ей. 
\item Монтирование корня. Если был initramfs, то в качестве корня выступает кусок оперативной памяти.
\item Загрузка драйверов.
\item Организация буферов ввода/вывода. У ядра есть буфер операций, ядро рассортировывает это по буферам драйверов, а драйвер формирует, собственно, запрос и отправляет в буфер устройства.
\item Разворачивание инфраструктуры для запуска процессов. Заводится таблица процессов. Само ядро -- нулевая запись.
kexec позволяет заменить образ ядра в оперативной памяти по файлу на диске. Увы, версию ядра поменять не получится.
\end{enumerate}
\item "Создание общества"

Запуск init. Ядро, собственно, может запускать любую программу, которую ему передали в параметре ядра init=.

Если прописать /bin/bash, то можно получить root-привилегии на локальной машине (если сможете прописать параметры ядра при загрузке).

sysv-init -- init, который использовался уже лет сорок, и всех всё устраивало. Когда linux стал десктопной ОС, потребовалась изоляция процессов и прочее. Теперь есть systemd.

Если надоело жить в chroot, можно сделать 
\begin{minted}{bash}
chroot
exec init 
\end{minted}
/etc/inittab содержит информацию о том, как настроить терминалы и организовать весь дальнейший мир.

Кстати, systemd тоже вначале есть обычный init, которму подменяют тело.

Уровни:

0 -- выключение

1 -- single user mode

2 -- предопределено пользователем

3 -- без графической оболочки

4 -- ?

5 -- с графической оболочкой

6 -- перезагрузка

В /etc/rc.d/ или /etc/init.d/ лежит куча shell-скриптов, которые запускают всё, нужное для runlevel. Часть скриптов запускает, часть скриптов останавливает.
/etc/init.d/ssh stop -- останавливает процесс ssh

systemd же совмещён с DBUS (сообщения типа "давайте примонтируем флешку, которую Вы только что воткнули"), одновременно запускает cgroups (ограничивает общение того, что запускается на разных терминалах, например, один терминал не может прочитать открытую другим флешку), содержит udev (обнаруживает устройства в real-time, вроде флешки, которую Вы только что воткнули) и специфичен для linux.


\end{enumerate}


\section{28.04.16}
\paragraph{systemd}
Умеет из любого приложения делать демон.
Ранее считалось, чтобы само приложение должно уметь становиться демоном.
/etc/inettab -- "systemd для бедных". Туда пишется список программ, которые должны запускаться как бы по требованию, например почтовый клиент, а демон inetd или xinetd их запускает, убивает по мере необходимости, а также обеспечивет вход и выход. Сейчас почти не используется.
Признаки демона:
\begin{enumerate}
 \item Писать в файл журнала (весь вывод). Файлы журнала обычно лежат в /var/log.
 Есть специальная служба syslog, которая должна всем этим заведовать. Если syslog обеспечивается библиотекой, то есть файл/папка syslog, где всё лежит (или даже это всё может отсылаться в сеть. Рекомендуется пользоваться этой утилитой.
 \item pid-файлы. Лежат в каталоге /var/run/имя\_демона, в них записан pid запущеного демона. Это нужно, чтобы нельзя было дважды запустить демона. Этот файл удалять при выходе должен сам демон, но если он умирает, то ничего не удаляется. Поэтому дополнительно выставляются блокировки fccntl'ом. При попытке обратиться к файлу на запись, это будет отклонено, и система скажет, что демон уже запущен.
 \item Конфигурационные файлы. Обычно лежат в /etc или /etc/имя\_службы.
 \item пользователь и группа, альтернативный корень (chroot) -- опционально, чтобы если взломали демон, то нельзя было получить доступ к реальной системе.
\end{enumerate}
\paragraph{Как стать демоном?}
Обычно запускается init'ом или его непосредственно сыновьими процессами. 
uid == 0, gid ==0, euid == 0, egid == 0

\begin{enumerate}
 \item Читаем конфиги.
 \item Открываем на запись pid-файл и блокируем его.
 \item Открываем файлы журналов на запись. Им нужно сменить владельца, если мы хотим, чтобы их читали другие пользователи.
 \item Закрываем 0, 1, 2 файловые дескрипторы.
 \item Делаем fork. В сыне меняем pgrp, sessid. Отец должен завершиться.
 \item ТруЪ-демоны меняют egid, euid на соответствующие пользователю, от имени которого работает демон, делают ещё один fork и завершают отца.
\end{enumerate}
systemd всё это делает сам. Если делать так в systemd, он увидит, что в cgroup никого нет, и грохнет процесс.

\paragraph{Память}
Регистры < Кэш < Оперативная память < Swap
free сообщает информацию о доступной памяти. В ядре есть инвертированная таблица страниц на каждый регион swap'а.

Таким образом, оперативная память -- кэш для swap'а. В таблице хранится число обращений и виртуальный адрес.
Периодически ОС запускает утилиту, которая проходится по всей виртуальной памяти и смотрит на их метки (грязный бит, последнее обращение, ...) и выбирается страница, обращение к которой было раньше всего.

Алгоритмы LRU и NRU. Оба выкидывают страницу, к которой дольше всего не обращались.

Вообще, читаем это место в Танненбауме.

\paragraph{Выделение памяти}

В ядре:
budgy-алгоритмы. Память не очень большого размера, но выдать быстро.
slab-алгоритм. Большой кусок памяти.
Все выделения памяти в ядре кратны размеру страницы.

В пользовательском режиме:
get\_free\_pages и kmalloc соответственно.

В пользовательском приложении: 
malloc из glibc, в данный момент реализация ptmalloc2, была dlmalloc.

В ядре:
память выделяется внутри оперативной (а не виртуальной) памяти. 
Проблема фрагментации: лучше обращаться к памяти, которая находится рядом.
Задача: найти такой пустой кусок, чтобы была минимальная фрагментация.
budgy -- выделяет только степенями двойки кратно числу страниц.
Хранится список дырок соответствующего размера. Берётся первая попавшаяся, "хвост" кладётся в соответствующий список.

slab заводит указатель, в котором хранится дополнительно размер диапазона. К хвосту одного можно подвесть другой.
Идея алгоритма -- использовать уже имеющийся диапазон.

malloc неэффективен в многопоточных приложениях. Куча одна и та же, поэтому нужно выставлять блокировку. Всё будет медленно.
tcmalloc (Google), jemalloc (malloc по умолчанию во FreeBSD и Mozilla)-- оптимизации.

В куче выделяется область, называемая ареной. Пока возможно, выделения происходят в ней. Если уже не хватает, происзодит системный вызов BRK, который расширяет.
Изначально у процесса одна арена, и когда один поток выделяет память, он блокирует всю арену. 
Расширять арену нельзя дальше, чем свободный swap. В реальности есть настройка vm.overcommit(выставляется sysctl).
0 позволяет программе выделять сколько она хочет памяти. Есла ОС поймёт, что уже не может выделять свободную память, она запустит службу oom, который выбирает и прибивает SIGKILL процесс, который недавно просил памяти, имеет её больше всех и с самым большим pid.
1 -- вместо отстрела процессов -- kernel panic.
2 -- выключить безграничный overcommit. overcommit\_ratio говорит, на сколько процентов (0-100) можно превышать размер оперативной памяти при полностью забитом swap'е.
Правильно отключить commit -- overcommit\_ratio == 0, по умолчанию 50.

Для выделения памяти внутри потоков испольуется nmap. Для каждого потока создаётся арена, и ими управляют nmap. BRK увеличивет размер всех арен сразу.


tcmalloc пользуется стандартным malloc'ом на нижнем уровне, но заносит её в свой собственный кеш. Выделение памяти внутри процесса быстрее. Так достигается минимизация обращений к глобальной куче.
gemalloc делит всю память на разные кучи по количеству ядер процессора. В каждой куче заводим свои арены.

\section{05.05.16}
\paragraph{Сигналы}
Сигнал -- некоторое сообщение процессу, которое устанавливается другим процессом (или этим же) или ядром. Обычно сигнализируют о каком-то состоянии операционной системы.
\mint{bash}|man 7 signal|
Сигналы SIGKILL 9 и SIGSTOP имеют особый смысл. На них нельзя установить обработчик, их нельзя игнорировать и нельзя замаскировать.
SIGKILL убивает процесс насовсем, SIGSTOP приостанавливает процесс до тех пор, пока к нему не прилетит SIGCONT (или SIGKILL).
3 очереди сигналов:
\begin{enumerate}
 \item Очередь обычных сигналов процессу "целиком".
 \item Очередь сигналов потоку (выставляются всякими pthread\_kill и проч.)
 \item Сигналы реального времени.
\end{enumerate}
Часть очереди реализуется как битовый массив. Там указывается, имел ли сигнал место. 
В другой части очереди хранится, собственно, информация о сигналах. Если в очередь добавляется сигнал, а в ней был сигнал такого же типа, он не добавляется, если очередь заполнена. Если приходит новый сигнал (которого нет в очереди), он обязательно добавится.
Таким образом, у нас есть всегда место под одного представителя сигнала каждого вида, и ещё некоторое место под "дубликаты".
Не имеет смысла хранить дубликаты только SIGKILL, ибо он сразу убъёт процесс.
Приостановленный процесс может принимать сигналы в очередь. Когда ему приходит SIGCONT, он возобновляется и обрабатывает сигналы, которые лежали в очереди, в порядке их поступления.

Что можно делать по приёме сигнала?
\begin{enumerate}
 \item IGN -- игнорировать.
 \item DFL -- по умолчанию.
 
DFL может быть:
Term   Прервать процесс.
Ign    Игнорировать сигнал.
Core   убить процесс и сбросить дамп памяти(см. core(5)).
Stop   Приостановить.
Cont   Продолжить
 \item Пользовательский.
\end{enumerate}

При приходе прерывания выполнение продолжается до тех пор, пока не закончится квант времени, выделенный процессу. 
Когда профилировщик захочет переключить процесс, будет изменён стек процесса на стек обработчика, переключится в пользовательский режим и вызовет функцию-обработчик. После её выполнения управление возвращается в ядро.

\paragraph{Сигналы потоку}
В многопоточных системах есть два случая: либо сигнал приходит всегда master-нити, либо приходит произвольной нити, у которой он не замаскирован.
Ещё можно в разных местах хранить маски??

\paragraph{Сигналы реального времени}
Выходят за рамки основных 32-х. Не слипаются (либо его не было и он добавляется, либо возвращается ошибка). Не могут быть выставлены ОС (только программой, как и SIGUSR1 и SIGUSR2).
Гарантируется, что все сигналы будут доставлены, причём в правильном порядке.

\ci|signal| -- выставляет пользователскую функцию-обработчик  \ci|void handler(int sig_num)|. Самая старая. Может сбрасывать обработчик после своей обработки.
\ci|sigaction| -- выставляет пользователскую функцию-обработчик  \ci|void handler(int sig_num, sig_info_t *info, sig_info_t *old_info)|.
\ci|kill| -- выставляет конкретный сигнал процессу/группе процессов.
\ci|raise| -- посылаем сигнал самому себе.
\ci|sigqueue| -- позволяет напрямую обращаться к очереди сигналов.
\ci|sigprocmask|, \ci|sigprocmask| -- выставляет сигнальную маску для процесса/потока.
\ci|pause| -- приостанавливает процесс до первого пришедшего сигнала.
\ci|sigwaitinfo|
\ci|sigsuspend| -- приостанавливает процесс, пока не придёт один из сигналов не из маски, переданной процессу.

\paragraph{Какие бывают сигналы?}
"Плохие" сигналы: действие по умолчанию -- abort. Первые два особенно плохи.
SIGILL -- в исполняемом файле встретилась инструкция, не поддерживаемая процессором (например, файл, лёжа на жёстком диске, поломался).
SIGBUS -- как-то нехорошо возмутилась аппаратно оперативная память (например, попытались записать в память три байта, а память не умеет писать три байта (нарушилось выравнивание), или забыли расширить shared memory (спорно; по идее должен кидать SIGSEGV).
SIGSEGV -- обращение к недоступному сегменту памяти.
"Терминальные" сигналы:
SIGINT -- Ctrl+C
SIGTSTP -- Ctrl+Z
SIGHUP -- терминальная линия перестала существовать (например, Вы общались с компьютером через USB-модем и выдернули его; или Вы общались с компьютером удалённо по SSH, и сеть отвалилась).

SIGALRM -- сигнал таймера. Считается, что sleep реализован через таймер, поэтому одновременно пользоваться таймером и sleep нельзя.

Способы убийства процесса, принятые в цивилизованном обществе:
SIGTERM -- предполагает, что процесс попытается закрыть файлы, написать что-то в лог, проч. Процесс должно понимать, что если он не уложится в какое-то определённое время, ему прилетит SIGKILL и завершит его нецензурным образом.

SIGTTIN, SIGTTOUT -- при попытке процесса обратиться на чтение/запись к терминалу, который ему не принадлежит.

\section{12.05.16}
\paragraph{Файловая система}

\paragraph{Напоминание: права доступа}

s -- suid bit -- позволяет запускать файл с правами владельца, а не запускающего.

Например, смена пароля. passwd -- программа с suid'ом, при запуске работает от root. Может менять файл /etc/master.passwd, имеющий права доступа root root root rw- --- ---.

t -- sticky bit -- нужен для каталога /tmp и запрещает не root удалять оттуда чужие файлы и каталоги.

\paragraph{Какие файловые системы бывают?}
\begin{enumerate}
 \item Псевдо-ФС. Используются ядром для своих ядрёных целей. Обычно целиком находятся в памяти и не связаны с внешним устройством.
 \item "На надёжном носителе". Считается, что носитель не подвержен ошибкам, и поэтому можно выкинуть ту избыточность проверок, присущую другим ФС. Напр., fat.
 \item "На ненадёжном носителе". 
 \begin{enumerate}
  \item Для ЖД.
  \item Для flash.
  \item Для магнитной ленты.
 \end{enumerate}
 \item Сетевые ФС. Напр., nfs -- для UNIX, cifs (samba) -- сетевые папочки windows.
 По сути мы имеем однозначное соответствие настоящей ФС сервера и настоящей ФС клиента. Изменения 
 \item Распределённые ФС. afs, gpfs, lustre. 
 Здесь целевая ФС физически может располагаться на разных компьютерах.
\end{enumerate}
\begin{enumerate}
 \item Простые. Операция выполняется сразу, и если что-то пошло не так, нельзя откатить. Касается псевдо-ФС и ФС на надёжных носителях.
 \item Журналированные. Содержат некий файл журнала, который поддерживает ФС в целостном состоянии. На время проведения операции данные о ней складываются в журнал, а после он стирается.
 \item Транзакционные. Файл журнала по сути и есть сама ФС. Хранятся все изменения. По сути, можно сделать "срез" на определённую дату. Недостатки: большой расход места на диске.
\end{enumerate}

\paragraph{Организация ФС на носителе}

\subparagraph{Магнитная лента}
В начале ленты лежит "заголовок" ленты, рядом его копия (вдруг основной повредился?). Там хранятся имена и позиции на ленте всех файлов, а также метаинформация (когда создан, когда читали, какие права). Путь является частью имени файла. Размер заголовка фиксирован, посему много файлов хранить нельзя. Пример -- tar-архив.

Недостаток: её нужно перематывать (низкая скорость доступа), ограниченный размер заголовка, низкая отказоустойчивость (решается созданием копий на нескольких лентах)

В реальности это шкафчик, который может сам себе менять ленты и следит за сохранностью своего содержимого (следит за тем, какая лента старая, и делает резервные копии).

Предполагается, что лента -- средство долговременного хранения, без необходимости частой перезаписи.

Внешняя фрагментация -- возможны зазоры между файлами (например, после удаления). 
При попытке записи нового файла, если он не влезает в зазор, возьмём новую кассету. 
Если же файлы лежат сплошняком, при попытке дописать в файл его придётся "выдернуть" и записать в другое место (на новую кассету).

Ленточный принцип организации информации используется в CD,DVD,Bluray. 

Файловые системы: UDF (сложная, если использовать с одноразовыми болванками, неразумно расходует место), ISO 9660 и модификации (проще и больше похожа на ленту).

\subparagraph{Ликбез: как устроен CD-ROM?}
\begin{enumerate}
 \item Один раз записываемый. 
 Лазер светит на диск и выжигает определённые места на его поверхности. Навсегда выжигает. Каждое место имеет координаты: сектор и дорожка. Посему можно считать данные.
 Важно, чтобы лазер всегда имел данные для записи. Если ему нечего писать, он продолжит светить и попортит Ваш диск.
 \item Фиксированное количество раз записываемый. Есть несколько точек, которые считаются за один кусок данных. Если одну точку выжечь, потом можно выжечь другую.
 Теоретически, можно просто один раз записать в n раз больше.
 \item Неограниченное число раз записываемый. Плотность записи меньше, стоят дороже, работают медленней.
 Подложка не выжигается, а обратимо меняет свои свойства. Если посветить лазером, например, другой частоты, они вернутся к исходным.
\end{enumerate}

ISO 9660 содержит понятие "сессия". Это некий участок диска. В начале диска (первая дорожка, первый сектор). Там хранится оглавление (несколько раз скопированное). 
Сессий может быть несколько. Считается лишь последняя. Например, если мы удаляем файл, то пишем новую сессию уже без этого файла. Далее хранятся файлы сплошняком.
Сессии обязательно начинаются с первого сектора. Вроде бы прошлая сессия хранит, где начинаются следующие.

\subparagraph{ФС на ЖД}
Считается, что у диска LBA. Данные пишутся блоками (стандартный размер -- 512 байт). Считается, что ЖД -- устройство с (более-менее) произвольным доступом, посему файлы хранятся блоками (которые желательно располагать подряд).

Внутренняя фрагментация -- фрагмент, отведённый файлу, занят не полностью. 
Например, хранение писем -- MAILDIR, огромное кол-во маленьких файлов, менее 10 КБ в среднем. Размер блока 1 МБ будет слишком большим, ЖД будет в основном хранить пустоту.

Описание самой ФС лежит в блоке в начале диска, который называется суперблоком. Он не содержит данных о файлах.

\paragraph{FAT -- File Allocation Table}
Это и есть суперблок, хранится 2 раза, содержит набор записей -- целых чисел, которые содержат информацию о всех блоках: блоки данных D, блоки swap'а S, bad блоки B, свободные блоки F.
После суперблока идёт корневой каталог.

Каждый блок файла в конце содержит ссылку на последующий блок или 0, если блок последний. Доступ в середину файла затруднён, ибо нам всё равно придётся ходить по блокам.

\paragraph{UNIX'овые ФС и NTFS}
\begin{enumerate}
 \item Суперблок.
 \item Множество индексных дескрипторов.
 \item Множество блоков данных.
\end{enumerate}
Структура:
Суперблок
(
Копия суперблока
Суперблок группы -- содержит разделы блоков индексных дескрипторов и блоков данных.
Копия суперблока группы
) повторяется n раз.
Размер группы фиксирован. Если грохнулась группа или даже суперблок, то данные можно будет получить (если они не были непосредственно на грохнутом месте). Можно, например, найти следующий суперблок.

В суперблоке:
\begin{enumerate}
 \item Битовая маска свободных/занятых блоков.
 \item Тип ФС.
 \item Когда создана, когда монтировалась, куда монтировалась.
 \item Число индексных дескрипторов.
 \item Примонтирована или нет.
\end{enumerate}
В суперблоке группы содержится своё, локальное, число индексных дескрипторов и своя битовая маска.

\end{document}
