\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}

 % Цвета для гиперссылок
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000FF} % цвет гиперссылок

\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\title{\textbf{Лекции по АКОСу}}
\begin{document}

\maketitle

\section{07.04.16}
\paragraph{Микроядро/монолитное ядро}
Ядро -- код, который загружается загрузчиком в момент запуска компьютера и работает в привилегированном режиме.
\begin{enumerate}
\item Монолитное ядро. Весь код ядра компилируется в один файл, в нём должны быть возможности для обработки всех возможных событий, и работает в привилегированном режиме.
\item Расширяемое ядро. Механизм модулей ядра, которые можно подгружать по требованию с внешнего устройства в оперативную память.

insmod *.ko (install module; kernel object)
Этот файл, написанный обычно на C или ассемблере, компилируется в объектный файл, после к нему добавляется метаинформация, позволяющая установить модуль в ядро.

modprobe имя\_модуля ищет файл .ko в каталоге /lib/modules/linux-.../. Есть ещё файл modules.map, который содержит места поиска модулей, а также их зависимости (например, чтобы подгрузить модуль для работы с жёстким диском, надо подгрузить модуль SATA-интерфейса и прочее)

lsmod выдаёт список уже подгруженных модулей.

Ядро должно обязательно иметь драйверы для работы с шинами (PCI Express, остальные не нужны), модуль прерываний, прочее -- это содержится в монолитном ядре. На это навешиваются модули, работающие с близкими к процессору шинами, потом ещё... Модули зависят друг от друга, и поэтому вряд ли можно так просто удалить модуль, близкий к ядру (рис. 1).

Модуль состоит из функции инициализации и убиения. Остальное -- опционально.
module\_init(...) -- модуль может принимать параметры (см. /etc/modules).
В список модулей нужно воткнуть заглушку stub, ибо компилятор добавляет ещё свои параметры.
module\_destroy(...)
Первую вызывает insmod, модуль может и не установиться с ошибкой
Вторую вызывает ядро и обязательно убивает модуль. 
Пользователь может командой rmmod попросить ядро убить модуль, и ядро в любое удобное ему время может удалить модуль, а может и не удалить (например, есть зависимости). rmmod -f форсирует, но ответственность за последствия возлагается на пользователя (надо гарантировать, что модулем никто не пользуется).

Плюсы монолитного/расширяемого ядра:
\begin{enumerate}
\itemРаботает быстрее (не надо часто переключать контекст при переходе от режима пользователя в привилегированный режим).
\itemМало косвенной адресации.
\end{enumerate}
Минусы:
\begin{enumerate}
\itemСложно писать.
\itemОшибка в модуле приводит к краху всего ядра. Оно может даже так сломаться, что не скажет об этом ( 
\itemМожно подсунуть заведомо неправильно работающий модуль (например, затирающий всю виртуальную память ноликами).
\end{enumerate}
Ядро может находиться в нормальном состоянии (всё хорошо). Оно может ещё совершать действия, но не может дальше продолжать работу в нормальном режиме. Тогда оно устраивает kernel panic (BSOD в Windows). Оно выводит информацию об ошибке и дамп памяти на экран и требует перезагрузки.
\item Микроядро.
Содержит механизм запуска/остановки процессов, базовые механизмы работы с системной шиной. Всё остальное реализовано как пользовательские процессы, работающие в пользовательском режиме в своей виртуальной памяти.
Есть подозрение, что Windows имеет микроядро. gnu hurd имеет.
Плюсы:
\begin{enumerate}
\item сложно сломать
\item проще программировать
\end{enumerate}
Минусы:
\begin{enumerate}
\item Медленное: очередь событий, которыми общаются процессы (а их очень много), становится узким местом.
\item Необходимость частого переключения контекста.
\end{enumerate}

\end{enumerate}

\paragraph{Процессы}
\begin{enumerate}
\item Данные процеса
\item Права на ресурсы
\end{enumerate}
Контекст процесса:
\begin{enumerate}
\item Аппаратная составляющая: регистры, таблица страниц, границы сегментов, ...
\item Пользовательская составляющая: данные процесса: код, переменные, ... 
\item Системная составляющая: 
\begin{enumerate}
\item информация о процессе
\item хранящаяся в операционной системе, не необходимая для выполнения кода: идентификатор процесса (pid), pid родителя (ppid), uid, gid, euid, egid (идентификатор процесса, группы, эффективные идентификаторы, т. е. те, которые процесс приобрёл, а не те, которые были вначале), таблица открытых файлов процесса, корень для процесса (операция chroot говорит, что нужно считать каталогом / какой-то другой каталог), терминал, к которому привязан процесс, группа процесса (pgid; чтобы процесс мог использовать терминал на чтение, нужно, чтобы его pgid совпадал с pid), идентификатор сессии sesid (задаёт иерархию процессов; при завершении прооцесса, у которого sesid совпадает с pid, ядро убивает все процессы с тем же sesid; поэтому надо позаботиться, чтобы демон был главным в своей сессии, иначе его могут принудительно убить), cgroup (ограничения ресурсов для всей группы процесса), квант времени, выделяемый ОС процессу для выполнения его задач до следующего переключения контекста; если квант времени большой, то программа может долго считать, например, что-либо, но нажатие кнопки быстро не обработается; при сборке ядро может быть оптимизировано под десктоп, сервер, систему ввода-вывода), ghbjhbntn (nice; меняется утилитой renice; чем меньше -- тем важнее; 1. Динамический приоритет, назначаемый ядром. Новый процесс должен иметь наибольший приоритет, а процесс, дольше всех простоявший в очереди -- наименьший.
2. Статический приоритет, назначаемый ядром. Привилегированные процессы, работающие в адресном пространстве ядра, имеют малый приоритет, чтобы их не задавили пользовательские процессы.
init имеет приоритет 1, т.к. он отслеживает ситуацию, когда с другими процессами что-то не так.
3. Статический приоритет, назначаемый пользователем root (pid 0).
4. Статический приоритет, назначаемый пользователем. Обычный пользователь не может уменьшить приоритет больше, чем на какое-то зафиксированное число.

Набор ограничений на процесс (как много файлов можно открыть, какой предельный размер пайпа может быть использован, какой размер виртуальной памяти может быть выделен, ...)
ulimit -a 
set\_limits
apropos 2 limits

Есть жёсткое ограничение, которое нельзя менять, есть мягкое ограничение, которое можно изменить. Если изменить до жёсткого, больше менять нельзя.


Сигнальная маска, очередь сигналов, список подключённых IPC-объектов. 
Состояние процесса: рис. 2.
exit\_status

Если у процесса убили отца, то ему нужен новый. Ядро назначает отцом процесс init. init смотрит, какая у процесса сессия: хорошая или плохая, и если плохая, тут же убивает его.
Состояние зомби: процесс завершил работу, но ещё никто не узнал, как. Обычно для этого отец должен вызвать wait() или waitpid(), при этом запись в таблице процессов удалится.


Терминал -- абстракция. Поддерживает посимвольный ввод и вывод. Считается, что буквы могут возникать не чаще, чем раз в сколько-то миллисекунд. /dev/tty ныне ассоциирован с клавиатурой и монитором, но раньше им могли быть разные экзотические устройства вроде принтера, модема, COM-порта. С каждым процессом ассоциирован терминал, если это процесс -- не демон.

\end{enumerate}


\end{document}
