\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{lmodern}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{minted}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}

 % Цвета для гиперссылок
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000FF} % цвет гиперссылок
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\newcommand{\tac}{\textasciicircum}
\newcommand{\tat}{\textasciitilde}
\newcommand{\tbs}{\textbackslash}
\newcommand{\ci}{\mintinline{c}}
\newcommand{\cl}{\mint{c}}
\newcommand{\bash}{\mintinline{bash}}

\emergencystretch=10pt

\title{\textbf{Семинары по АКОСу}}
\begin{document}

\maketitle

\begin{center}
 \href{https://github.com/Wiki-fan/didactic-duck}{https://github.com/Wiki-fan/didactic-duck}
\end{center}

\section{??.03.16}

\paragraph{Что есть файл?}

\begin{enumerate}
\itemПочти аппаратура. Место на диске и т. п. Предоставляется драйвером диска.
\itemОперации, предоставляемые ОС (возня с файловой системой через системные вызовы).
\itemВзгляд стандартной библиотеки языка.
\end{enumerate}
Есть буфер операций с файлами. Есть операция принудительного сброса буфера fflush(FILE*). Есть буфер в ядре. Есть (может быть) буфер в самом винчестере, с которым он сам решает, что делать. К нему можно обращаться на уровне ядра.

Если операция не может быть завершена (диск отвалился, например), операция откладывается до тех пор, пока не можно будет сделать (можно вытащить диск, починить, вставить обратно, и операция завершится).


\paragraph{Что можно делать с файлами?}

\cl|FILE* fopen()|

DIR* opendir(). Папку можно читать readdir.

В файле есть курсор, указывающий текущую позицию. Его можно двигать fseek. ftell говорит текущую позицию курсора в файле.

Функции с суффиксом o позволяют работать с большими файлами (которые нельзя просто так адресовать).

fstat позволяет узнать параметры файла.

Стандартные потоки: stdin, stdout, stderr.

Параметры, передаваемые файлу при открытии -- читать маны.

Поток символов.

Чтение. 

getchar возвращает int, младшие биты содержат символ, остальные -- "служебную информацию", которой обычно нет. Если конец файла, то возвращает EOF, который скорее всего -1. fgetc(FILE*) -- то же самое.

ungetc кладёт символ обратно в поток. Положить можно только последний символ.

fgets читает строчку до символа '\textbackslash{}0' или '\textbackslash{}n'. 

scanf, fscanf. Для спецификаторов вывода -- читать маны.

Запись.
puts, fputs.
putchar, fputc.
fread, fwrite.

\paragraph{Работа со строками}

<ctype.h>

Определение типа символа -- isalpha, isdigit и всё-всё-всё.

<string.h>

Читать маны. 

Обратить внимание на memcpy, memmove. Например, memmove позволяет переместить строки, накладывающиеся друг на друга в памяти.

\paragraph{Домашнее задание}

wc, sort. Написать комбинацию этих двух программ.

Сортировать нужно строки, в конце которых стоит '\textbackslash{}n', а остальные символы могут быть произвольными (даже '\textbackslash{}0'). Строки сортировать лексикографически, результат складывать в другой файл.

Можно читать весь файл в память, но нельзя отводить память под файл, узнав его размер fstat'ом (то есть нужно использовать realloc).

Вывести число строк, слов и символов в файле. Слова разделены пробельными символами, пустая строка есть строка.

Нельзя использовать безопасную функцию считывания строки. Нельзя использовать string.h.

\paragraph{Ликбез}

man man

apropos -- поиск по заголовкам man'ов.

Секции man:

1 -- системные утилиты и программы.

2 -- системные вызовы.

3 -- библиотечные функции.

4 -- специальные файлы (обычно из /dev).

5 -- описание конфигов.

6 -- программы для Xorg.

7 -- философская (что такое, зачем вообще нужно; напр., man 7 ip -- описание IP, man 7 signal -- описание всех сигналов ОС).

\section{10.03.2016}
\paragraph{Short Task 4}

Реализовать макрос побитовой распечатки в виде отдельного .s-файла, написанного на ассемблере.
Только long.
\ci|print_bits(long int number, char* str)|. ВЕСЬ ОТВЕТ (с красивостями) писать в str. str хорошая, выделена вне, в неё всё влезает.

\paragraph{Требования к оформлению файлов.}

\begin{enumerate}
\itemФайл именовать латиницей.
\itemВсе файлы именовать маленькими буквами (snake case, короче).
\itemЦифра в имени может быть лишь в конце.
\itemЗАГЛАВНЫМИ БУКВАМИ или С Большой Буквы нужно писать Readme, Makefile, Release\_notes.
\itemВ README писать информацию, относящуюся к данному каталогу.
\itemПримеры работы принято класть в каталог examples.
\end{enumerate}
\paragraph{Makefile}

Набор команд по приведению программы из исходников в рабочее состояние.

make будет компилировать с учётом этого файла. Зачастую используется GNU Make.

CC=gcc говорит, чтобы .c собирались gcc.

CFLAGS=-Wall -ansi -pedantic -- флаги компиляции.

PROGRAMS= converter tests -- имена программ.

Компиляция осуществляется по целям. По дефолту цель all

all: \$(programs) -- правило. Левая часть правила зависит от правой части. Левая часть должна либо отсутствовать, либо быть старее, чем правая. 
(эти части -- файлы. Если всё собрано, то ничего как бы и не запускается.)

Образуется дерево зависимостей файлов от других файлов. Потом make начинает собирать дерево от листьев. Таким образом, если изменился только один файл, можно пересобрать только путь из этой вершины до корня.

\begin{minted}{makefile}
converter: converter.o xz.o
	$(CC) $(CFLAGS) -o converter ... 
	$(CC) $(CFLAGS) -o $@ $^ -- более оптимизированно

%.o : %.c -- шаблонное правило. % -- шаблон в смысле правила.
	$(CC) $(CFLAGS) -c $^

	$^ -- всё, что стоит после двоеточия. $< -- первое из этого.
\end{minted}
Цель .PHONY: doc -- делает все цели, указанные справа, устаревшими. Надобно для работы с каталогами (если меняем файл в каталоге, каталог не меняется, make не видит изменения).

Цель clean: -- приводит каталог к тому состоянию, которое было до сборки.

Цель install: -- действия, необходимые для того, чтобы развернуть код в место его будущей работы.

Переменная \bash|PREFIX=$(HOME)/bin|. Так обычно указывают, куда развёртывать программу.

При компиляции можно явно указать цель (иначе выполняется первая цель в Makefile). Напр., make clean.

Если хочется вызвать make из подкаталога, то \bash|$(MAKE) -C doc |

SOURCES = \$(wildcard *.c) -- образец того, что нужно взять из файловой системы.

OBJS=\$(patsubst \%.c,\%.o, \$(sources))

little\_task\_\%: little\_task\_\%.o

В makefile есть директива include, напр. include config. Она утаскивает всё из config.ac. Есть ещё automake.

Директива gcc -M заставляет сгенерить файл зависимостей в виде makefile.

\section{11.03.16}
\paragraph{Низкоуровневый IO}
Файлы в UNIX -- абстракция. Их даже может не быть в файловой системе. Для них определены операции 
\begin{enumerate}
\item read. Считать с такого-то адреса в такой-то адрес. Этим управляет ОС. Операция read -- своего рода запрос. Она не гарантирует выполнение. Может просто выйти и сказать, что прочитала столько-то, а дальше не удалось.
\item write. То же самое, только на чтение.

Если открыть один и тот же файл дважды, он будет считаться как два файла. Операции с разными файловыми дескрипторами будут не синхронизированы. 
\item ioctl. Управление устройством (например, если файл на самом деле -- терминал, характеризующийся шириной, управляющими клавишами и т. д.
\item fcntl. Нужен для установки разных штук, в основном блокировок. Блокировать можно файл, можно диапазон. Тогда никакая другая программа не сможет обращаться. Не у всех видов файлов (например, файл клавиатуры) можно блокировать диапазоню
\item lseek. Сдвигает файловый курсор, если это возможно.

Когда файл открывается, в системе заводится таблица открытых файлов процесса. Там всегда (в нормальном состоянии, если ничего специально не делать) лежат три строчки:

0. stdin

1. stdout

2. stderr

Каждый открытый файл добавляет свою строчку. fclose стирает строчку
Таблица имеет фиксированный размер, определяемый ОС. Таким образом, есть ограничение на количество открытых файлов процесса. Можно навесить принудительное ограничение. 

ulimit -a выводит все ограничения.

\item \ci|int dup(int fd);| Смотрит fd строчку таблицы, ищет свободную и копирует fd туда, возвращая номер, куда скопировал. Если свободной нет, возвращает -1 и выставляет errno.
Например, если скопировать что-то на нулевую строчку, то считывание из stdin на самом деле будет считывать из файла.

\item \cl|int dup2(int fd_what, int nek_place);|
Если обращаемся в каком-то месте к неоткрытому файлу (пустой строчке), то ошибка. Если открыть дважды один и тот же файл, строчки будут разные.

\ci|FILE* fdopen(int fd, ...)| fd -- файловый дескриптор. Просто возвращает FILE*, привязанный к такому-то дескриптору.
\item \ci|int open(char* file_name, mode_t mode, perm_t perms)|
Возвращает -1, если не открылось.

perms опционален. Если не указано, используется umask или fmask.

Права можно выставлять константами из <systypes.h>
mode: O\_RDONLY, O\_RDWR, O\_TRUNCATE (стереть всё содержимое файла), O\_APPEND(дописать), O\_WRONLY, O\_CREAT (создать файл), O\_LARGEFILE (lseek не работает, нужно использовать длинный lseek), O\_DIRECTORY, O\_SYNC (запрет на буферизацию на уровне ядра ОС), O\_ASYNC (можно использовать aio\_read, aio\_write, которые не ждут завершения операции, а продолжают выполнение программы; можно узнать, завершилась ли операция, через aio\_wait), O\_CLOEXEC (закрывать файл, когда переходим с одной программы на другую), O\_EXCL (запрет создать файл, если он уже открыт).

\end{enumerate}

\section{17.03.16}
\paragraph{Параметры командной строки}
./prog a "b c" d

int main(int argc, char** argv, char** argp)

argc = 4

argv: "./prog" "a" "b c" "d" NULL

argp: "NAME=значение"

getenv -- поиск переменной и получение значения.

setenv -- выставить значение.

getopt, getopt\_long из <getopt.h> -- красиво получать параметры командной строки вида -d или --version.

Принято иметь -h или --help, -v или --version.

Version -- трёхчисельный номер. Последняя -- незначительные изменения, средняя -- изменения, затрагивающие API, первая -- изменения, затрагиващие концепцию програмы и значительно меняющие API.

getopt предполагает, что будет вызываться многократно и утягивать аргументы по порядку. Выставляет optind -- текущий параметр.

\begin{minted}{c}
switch(optind)
{
case 'h':
напечатать help;
break;
...

case 'f':
file_name = optarg;
break;
case '?':
передан какой-то левый параметр;
break;
}
\end{minted}
\paragraph{Короткое задание 5}
Дописать разбор параметров getopt'ом. Нужен help и version. Сделать сообщения в духе: распарсил строку, буду конвертировать оттуда туда, конвертирую, сконвертировал.

Результат складывать в отдельное задание.
\paragraph{typedef}
\begin{minted}{c}
typedef int Matrix[3][3];
// Аналогия: int my\_ints[3][3] -- так описывается переменная.
Matrix *m;
Matrix ma[2];
m = ma;
m++;
*m = 10;
// 10 запишется в элемент с номером [0][0].
*m = m[0] = 0[m]
//Арифметика с указателями производится кратно размеру объекта, на который указатель указывает.
typedef int** Matrix; -- совершенно другое. Массив указателей. Сдвиг на int*, а раньше на 9 интов.
Теоретически куски int* могут быть в разных участках памяти.
\end{minted}
\paragraph{Порождение процессов}
pid\_t, описанный в <unistd.h>

Процесс делается двумя вызовами: clone и fork.

\ci|pid_t fork();|
Делает процесс-сын. Процесс-сын думает, что он на самом деле выполнялся с самого начала так же, как родитель. С его точки зрения fork возвращает 0, родителю возвращается pid сына. Если процесс не создался, возвращает -1.
fork делает полную копию выполняемой программы, а различить их можно значением, возвращаемым fork.

getpid -- свой pid. getppid -- pid родителя.

Если родитель исчез, его родителем назначается процесс 1 (init). У процесса 1 родитель 0, 0 -- это ядро.

Если нужно запустить другой процесс, копируем себя и меняем тело процесса.
execve, execvp, execlp, execll.

\begin{minted}{c}
execlp(char* path, char* argv_0, ..., NULL); //l for list.
execlv(char* path, char** v); //v for vector.
\end{minted}

\mintinline{c}|pid_t wait(int* status)| -- ждёт завершения первого попавшегося сыновьего процесса, выдаёт pid завершившегося сына. status -- код возврата и какая-то служебная информация (2 байта под статус, остальные два -- как завершился процесс). В syswait описаны макросы, которыми можно разбирать эти результаты.

\paragraph{Где ищутся исполняемые файлы?}
Есть переменная окружения PATH. Напр., \bash|PATH=/bin;/usr/bin;/usr/sbin|. 

При попытке запуски программы каталоги из PATH обходятся по порядку, и если исполняемый файл с таким-то именем найден, он запускается. 
Например, если ls найден в /usr/bin, неявно вызывается /usr/bin/ls.

\section{18.03.16}
\paragraph{Неименованные каналы}
\cl|int pipe(int fds[2]);|

Предназначены для общения родственных (имеющих общего предка) процессов.
В ядре заводится буфер FIFO ограниченного размера. В таблице открытых файлов заводятся две записи, которые ведут внутрь ядра. К этим записям применимы read и write.

[0] -- вход, [1] -- выход. Возвращает через fds* присвоенные файловые дескрипторы. Возвращает 0, если всё хорошо, -1, если плохо.

При fork таблица открытых файлов наследуется.

Проблема: при обращении из разных источников никоим образом не синхронизируются операции считывания-записи.

При заполнении буфера write завершится только при освобождении буфера или уничтожении буфера.

При пустом буфере read завершится, только когда данные запишут.

Запись в pipe атомарная. Пишутся всегда какие-то куски. Например, за один write пишется 500 символов, если одновременно попытаться записать 403 и 505 символов, то будут значимые куски 500, 5, 403, разбросанные произвольным образом.

На данном моменте автор заснул. Написанное делее не следует воспринимать всерьёз.
\textit{Прим. авт.}

\begin{minted}{c}
->| | - запись
  | |
->| |
  | |
<-| | - чтение
\end{minted}

Если у процесса закрылся последний pipe на запись, всем читающим присылается  SIGPIPE.

Если же последняя стрелка на запись удалилась, то все стрелки на считывание получают EOF.

\section{24.03.16}
\paragraph{Длинное задание 2}
less

Должна узнавать ширину, высоту терминала, показывать текст, скроллить. Никаких ncurses! read, читающий из терминала, поможет отловить нажатия клавиш. Терминал нужно открыть в non-canonical mode (см. пример в примерах).

Весь файл с текстом можно читать в память. Стрелочки двигают на один символ. Если дошли до конца самой длинной строки, не крутить дальше.

less -n (слева нужно указывать номера строк типа 1: ...) имя\_файла

Можно использовать безопасную функцию считывания строки.

less > foo -- нехорошо. Чтобы определить, терминал ли это, используем isatty().

Выход по q или ctrl+c.

\mintinline{bash}|man tty_ioctl|

Дедлайн через две недели.

\paragraph{Сигналы}
\cl|kill(pid_t pid, int sig_num)|
-1, если не послалось, 0, если хорошо.

Все процессы в UNIX по группам. -1 -- всем процессам с id > 1. 0 -- все процессы с той же группой. -n -- всем процессам с группой n. n -- процессу с номером n.

man 7 signal -- общая информация о сигналах. 

kill -- убить.

abort -- убить с дампом памяти.

Игнорировать.

Остановиться.

Продолжить выполнение.

Для всех сигналов, кроме SIGKILL (убить просто совсем нафиг) и SIGSTOP, можно переопределить действия.

SIGUSR1, SIGUSR2 генерируют только программы программистов (например, задание перечитать конфигурационный файл).

Сигналы имеют свойство слипаться, т. е. два SIGUSR1, посланные подряд, могут считаться за один. 

Сигналы реального времени тоже шлёт программист, они не слипаются, но реализованы сложнее, работают медленнее.

\begin{enumerate}
\item SIGINT -- ctrl+c в canonical mode -- когда хотим завершить программу.
\item SIGTSTP -- ctrl+z -- предполагается. что программа будет остановлена.
\item SGIPIPE -- см. ранее.
\item SIGCHLD -- приходит, когда сыновний процесс завершился или остановился.
\item SIGILL -- попытались использовать инструкцию от другой архитектуры процессора.
\item SIGBUS -- ошибка на шине памяти.
\item SIGSEGV -- ошибка сегментации.
\item SIGALRM -- когда сработал таймер, выставленный функцией alarm.
\item SIGABRT -- данный процесс нужно убить с дампом памяти.
\item SIGCONT -- возобновить работу.
\end{enumerate}

\cl|typedef void (*sig_handler_t)(int sig);|
\cl|sig_handler_t signal(int signal, sig_handler_t handler);|
Возвращает старый обработчик. Для совместимости со старыми версиями функция-обработчик при своём вызове должна зарегистрировать себя как обработчик.

sigaction -- современный способ делать то же самое.

\cl|typedef void(sig_handler_t)(int sig, sig_info_t info)|

Можно установить сигнальную маску системным вызовом sigprocmask (на время обработки данного сигнала запретить другие сигналы, кроме SIGKILL и SIGSTOP), передать дополнительные параметры и проч.

pause() приостанавливает процесс до прихода первого попавшегося сигнала.

sigwaitinfo(...) выставляет info.

Нужно беспокоиться, чтобы компилятор не кешировал и не менял адрес переменной в памяти, а то в обработчике и основной программе были бы (возможно) разные штуки. К тому же, printf, работающие одновременно, могут начать одновременно писать в буфер.

\begin{minted}{c}
volatile int a; 
void handler(int sig)
{
a = 15; printf("bbbb"); 
}
int main() {
if (a == 10) {
print("win");
}
}
// Зам. По-хорошему тут нужен write, который атомарен.
\end{minted}

\paragraph{Короткое задание 6}
Программа, которая пишет pid первых десяти процессов, которые прислали ей сигнал. Дедлайн -- завтра.

\section{25.03.16}
\paragraph{Короткое задание 7}
Та же штука, что и на семинаре, для дерева процессов (со внуками). Можно использовать только один канал. Дерево см. на картинке (картинку искать самим; кто-то точто зафотал).
Рекомендуется использовать sigaction (для маскирования сигналов). По хорошему, нужно узнать сигналы реального времени.

\section{08.04.16}
\paragraph{Именованный канал}
Позволяет передавать данные между не родственными процессами.

\cl|mkfifo(const char* file_name)|

В файловой системе заводится специальный файл, который на самом деле отображается в оперативную память. После этот файл можно просто открыть.

Процесс при открытии файла на запись повисает до тех пор, пока кто-нибудь не откроет его на чтение.

Сокеты семейства PF\_UNIX -- то же самое, только с ними работают, как с сетью.

\paragraph{Потоки/threads}
Если при fork создаётся копия сегмента данных, состояния регистров, стека, то у потока сегмент данных не копируется. Это означает, что глобальные переменные у них одни и те же, и каждый может их менять. Потенциально, переменные, описанные в куче, тоже общие, т. к. другие потоки могут до них добраться (знать, где лежат данные, будет только один поток).

Системный вызов clone -- единственный способ создать процесс. При одном наборе параметров получается fork(), при другом -- pthread\_create.

Библиотека <pthread.h>
Компилировать свои программы с ключом -pthread или -lpthread.

Процесс порождает внутри себя нити. pthread\_exit выходит. pthread\_join сливает обратно. 
Главная нить называется master\_thread. pthread\_detach позволяет отделить нить от главной 
pthread\_cancel из master-нити досрочно убивает порождённую нить.

Функции бывают потокобезопасные (thread-safe; не используют глобатьные переменные, по завершении работы всю свою память в куче убивают или возвращают как значение. Она не должна менять состояние между выводами (например, как делает rand()) и thread-unsafe (небезопасные). Последние обычно работают медленнее. В stdlib безопасные имеют обычно суффикс \_r.
Посему нужно либо использовать безопасные версии, либо заботиться, что функции будут выполняться строго последовательно.
\begin{minted}{c}
pthread_t thread1;
typedef void* (*thread_body_t)(void*);
int pthread_create(pthread_t *thread, const pthread_...* attr, thread_body_t body, thread_id, void* arg);
\end{minted}

\paragraph{Mutex}
mutex имеет состояние locked или unlocked.

Любой процесс может заблокировать mutex, если он был разблокирован.

\begin{minted}{c}
pthread_mutex_lock();
// критическая секция кода
pthread_mutex_unlock();
\end{minted}

Процесс может заблокировать mutex. Другие процессы будут виснуть на попытке входа в mutex, пока первый процесс не разблокирует его.

\ci|pthread_mutex_trylock| пытается заблокировать mutex, если он уже заблокирован, возвращается ошибка, если разблокирован, возвращается успех.

\ci|time_lock| блокирует на время, и даже если предыдущий процесс не вышел, по истечении времени mutex разблокируется.

\ci|pthread_mutex_init(), pthread_mutex_destroy()| создаёт и уничтожает mutex соответственно. При уничтожении мьютекса все процессы, стоящие на нём, разблокируются.

\paragraph{Условные переменные(cond\_var)}
В критической секции можно манипулировать условными переменными.

\ci|pthread_cond_init, pthread_cond_destroy| -- создание.

\ci|pthread_cond_wait, pthread_cond_signal, pthread_cond_bcast| -- манипулирование.

Процесс, пришедший к wait, немедленно разблокирует mutex, а сам процесс виснет на wait, пока кто-нибудь не вызовет signal или bcast ( причём необязательно из критической секции. Так, например, можно сделать барьер, чтобы ни один из потоков не пошёл дальше, пока все из них не дойдут до этого барьера.
signal разблокирует одного случайного, bcast -- всех.

\section{14.04.16}
\paragraph{IPC SystemV}
Есть ещё более современный POSIX IPC, но его мы не изучаем.

Средство взаимодействия неродственных процессов. 
Примитивы:
\begin{enumerate}
\item Разделяемая память: если у потоков была общая data, то сейчас у каждого процесса есть своя data, но какой-то участок (не обязательно одинаковый) адресного пространства отображается на общий кусок оперативной памяти.
\item Семафоры, которе используются аналогично мьютексам.
\item Очереди сообщений (fifo; сообщения имеют приоритеты, типы, не имеют адресата).
\end{enumerate}
\ci|ftok(путь_до_файла, char project_id)| -- вычисляет ключ по path.

Вообще, предполагается, что SystemV -- средство общения всяких демонов.


\ci|id = int shmget(key, size, flags)| -- shared memory get -- выделяет разделяемую память и возвращает её идентификатор.
Параметры: IPC\_CREAT,
IPC\_EXCL (exclusive; не создавать, если уже есть, вернуть ошибку).

Наряду с этим побитовым ИЛИ указываются права доступа, например 0600 | IPC\_CREAT. Уничтожать объект по идее должен тот, кто его создал.

\begin{minted}{c}
void* shmat(id, void* pointer, flags); // Если pointer==NULL, система сама выберет свободный кусок. 
attach, detach
semget(key_t key, int num_sems, flags)
shmctl(IPC_RMID) // удаление IPC-объектов.
semctl

struct sem_buf
{
int sem_num;
int sem_op;
int flags; // Обычно 0.
}

semop(id, ops, num_ops)
\end{minted}
Операции -- массив структур. Эта функция, собственно, производит операции. 
op > 0 -- безусловно увеличивает значение семафора. Эта функция атомарна и непрерываема. Все обработчики всё равно возвращаются в semop. Менять его можно только semop'ом. Даже если поменяли на нужное, пока висит на semop'е, не развиснет. Висит, пока значение семафора не поменяется функцией semop.

op==0 -- блокирует, пока значение семафора не станет 0. 
op<0 -- уменьшает значение семафора на это число, если это возможно.

\section{15.04.16}
\paragraph{Очереди сообщений}
Дополнительная синхронизация процессов.
\begin{minted}{c}
struct mes_t {
{
long message_type;
message_body ...
Размером сообщения считается размер его тела.
}
msgget
\end{minted}
msgsnd берёт конкретный экземпляр структуры и кладёт в очередь сообщений в ядре.
msgrcv.
Если >0 из очереди выбираются процессы с таким же типом, если нет таких, то виснет.
Если <0 берётся процесс с наиболь??
\paragraph{Короткое задание №???}
Переписать клиент-сервер с использованием очередей сообщений.
В типе сообщения полезно кодировать код операции и pid посылателя.
Вместо этого можно завести процедуру идентификации клиента, и присваивать ему номер (ограничив, заодно, количество возможных клиентов).

\section{21.04.16}
\paragraph{Long Task 4}
Дедлайн -- начало зачётной сессии.

Написать shell с возможностью запуска конвейера произвольной длины и перенаправлением потоков. Приоритет у них больше чем у |.  >> дописывают в файл.

В конце может присутствовать \& (запускать всё это в фоновом режиме).

ls -l ..... | .......... | ............. > ................ < ...................

Можно пользоваться всем, что есть в стандартной библиотеке C. Встроенные команды типа cd можно не реализовывать.

\paragraph{Long Task 3}
Квака в консольке по сети. Можно пользоваться всей стандартной библиотекой C. ТЗ будет на майских праздниках.

\paragraph{Сокеты}
\cl|int socket(int domain, int type, int protocol)| Создаёт сокет, возвращает файловый дескриптор. Можно писать и читать.

type -- SOCK\_STREAM или SOCK\_DGRAM (потоковый или для обмена пакетами (датаграммами), имеющими адресата, адресанта и размер).

Для работы с датаграммами используется sendto, recvfrom (UDP-протокол).

domain : PF\_INET (позднее будем пользоваться стеком протоколов TCP/IP, UDP/IP, ICMP/IP), 
PF\_INET6 (для IPv6), 
PF\_RAW (чтобы пихать сырые данные в сетевую карту), 
PF\_IPX, PF\_APLETALK и т. д.
PF\_UNIX позволяет всё это взаимодействие реализовать локально через файловую систему.

Конкретные протоколы лежат в /etc/protocols, есть функция getprotobyname, который по имени получает константу.

Далее -- для TCP.

Есть клиент и сервер. Оба запускают socket. 

Сервер должен захватить порт вызовом bind(short). Порты до 1024 захватывает только root.

После сервер должен быть переведён в режим слушания listen(..., 5). 5 -- сколько клиентов одновременно может устанавливать соединение с сервером.

Системный вызов accept вешает процесс, пока кто-нибудь не захочет с ним поговорить.

Если кто-то хочет поговорить, создать новый socket клиента, через который с ним можно общаться.

shutdown позволяет закрыть сокет на чтение либо на запись (оптимизация для ОС).
Если сокет не нужен, нужно сделать close.

Если нужно обрабатывать нескольких клиентов, можно запилить poll, который позволяет ждать определённых событий. 
Можно делать fork (дорого) или pthread\_create (менее дорого), и обрабатывать отдельных клиентов в отдельных потоках.

Клиент должен понять, как именовать сервер.
gethostbyname или gethostbyaddr
После можно присоединиться к нему connect.

\section{22.04.16}
Пишем клиент и дописываем сервер.
\bash|valgrind --tool=dtd|

\section{06.05.14}
\paragraph{Асинхронная работа с ``файлами``}
Есть два механизма.
\paragraph{Механизм опроса через timeout}
Системные вызовы poll, select (deprecated).
Наивно:
\begin{minted}{c}
while(timeout) {
  спросить;
}
\end{minted}
Каждый вопрос -- системный вызов. Медленно.
\begin{minted}{c}
struct pollfd {
  int fd;
  short events;
  short revents;
}
\end{minted}
Массив этих структурок пихается в poll.
poll(pollfd, int count, int timeout)
timeout (в миллисекундах) -- сколько ждать события. На это время процесс блокируется. Если за это время произошли какие-то события, то они указываются маской в revents, а сам poll возвращает количество случившихся событий.
timeout 0 означает выяснение состояний дескрипторов в данный момент. Отрицательное значение значит, что поток виснет в полле непосредственно до наступления событий.
\paragraph{Явное использование асинхронного ввода-вывода}
man 7 aio
Регистрируем события, о которых мы хотим, чтобы нас уведомила ОС, и пишем обработчики.
Регистрируем нотификатор. Если состояние одного из объектов, с которым связан нотификатор, меняется, приходит сигнал.

Открываем файл с флагом O\_ASYNC, заводим структуру, которая связывает операцию (aio\_read или aio\_write) с файлом. Выход из функции происзодит мгновенно, а ОС потом сама пишет в буфер/в файл. Программист сам виноват, если попытается записать по тому же адресу/перекрывающийся кусок.
По завершении обмена можно попросить присылать сигнал.
aio\_error проверяет ошибки при записи, aio\_return проверяет exit status такой, как будто бы он выполнялся обычными read и write. aio\_suspend приостанавливает.
\paragraph{ioctl}
Можно зарегистрировать команду на файловый дескриптор, так, что при чтении/записи прилетает сигнал SIGIO. В linux не работает.

\section{12.05.16}
\paragraph{Время}
\subparagraph{Спросить время}
time, clock, gettimeofday -- возвращает астрономическое время с начала эпохи (1 января 1970 г.)


ctime, strptime, strftime -- с применением time zone  приводит к человекочитаемому виду.

utime -- время, которое процесс провёл в режиме исполнения себя (без времени внутри системных вызовов), stime -- время, которое процесс провёл внутри системных вызовов.
Информацию об этом можно получить системным вызовом times
\subparagraph{Поставить таймер}
setitimer, getitimer (deprecated). Ставит таймер на SIGALRM (учитывает астрономическое время) (может придти процессу только в тот момент, когда будет исчерпан его квант времени) или SIGVALRM (учитывает процессорное время). Не сигналы реального времени, могут слипаться.

clock\_gettime -- linux-специфичные таймеры. Делают то же самое, но близки к ядру.

POSIX-функции для работы с таймером.
Линковать с -lrt.
timer\_create, timer\_delete -- регистрируем в ОС некий таймер и привязываем его к данному процессу.
timer\_settime -- инициализация и выставление времени/событий.
timer\_gettime -- посмотреть время на таймере.
timer\_getoverrun -- посмотреть время, прошедшее после события (например, к Вам только что прилетел сигнал, и Вы хотите узнать, сколь давно было срабатывание таймера, его вызвавшего).
struct sigevent. SIGEV\_NONE -- никак не информировать процесс. SIGNAL -- отправка сигнала. THREAD -- создание нити с заданным обработчиком. THREAD\_ID -- если точно знаете, какой thread-объект будет обрабатывать событие (Вы заводите переменную pthread\_t, но не создаёте поток; его по таймеру создаст система) (linux-специфика).

\end{document}