\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amssymb}
\usepackage{mathtext}
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{minted}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}

 % Цвета для гиперссылок
\definecolor{linkcolor}{HTML}{799B03} % цвет ссылок
\definecolor{urlcolor}{HTML}{0000FF} % цвет гиперссылок
\hypersetup{pdfstartview=FitH,  linkcolor=linkcolor,urlcolor=urlcolor, colorlinks=true}

\newcommand{\tac}{\textasciicircum}
\newcommand{\tat}{\textasciitilde}
\newcommand{\tbs}{\textbackslash}

\title{\textbf{Семинары}}
\begin{document}

\maketitle

\section{??.03.16}

\paragraph{Что есть файл?}

\begin{enumerate}
\itemПочти аппаратура. Место на диске и т. п. Предоставляется драйвером диска.
\itemОперации, предоставляемые ОС (возня с файловой системой через системные вызовы).
\itemВзгляд стандартной библиотеки языка.
\end{enumerate}
Есть буфер операций с файлами. Есть операция принудительного сброса буфера fflush(FILE*). Есть буфер в ядре. Есть (может быть) буфер в самом винчестере, с которым он сам решает, что делать. К нему можно обращаться на уровне ядра.

Если операция не может быть завершена (диск отвалился, например), операция откладывается до тех пор, пока не можно будет сделать (можно вытащить диск, починить, вставить обратно, и операция завершится).


\paragraph{Что можно делать с файлами?}

FILE* fopen()

DIR* opendir(). Папку можно читать readdir.

В файле есть курсор, указывающий текущую позицию. Его можно двигать fseek. ftell говорит текущую позицию курсора в файле.

Функции с суффиксом o позволяют работать с большими файлами (которые нельзя просто так адресовать).

fstat позволяет узнать параметры файла.

Стандартные потоки: stdin, stdout, stderr.

Параметры, передаваемые файлу при открытии -- читать маны.

Поток символов.

Чтение. getchar возвращает int, младшие биты содержат символ, остальные -- "служебную информацию", которой обычно нет. Если конец файла, то возвращает EOF, который скорее всего -1. fgetc(FILE*) -- то же самое.

ungetc кладёт символ обратно в поток. Положить можно только последний символ.
fgets читает строчку до символа '\textbackslash{}0' или '\textbackslash{}n'. 
scanf, fscanf. Для спецификаторов вывода -- читать маны.

Запись.
puts, fputs.
putchar, fputc.
fread, fwrite.


\paragraph{Работа со строками}

<ctype.h>

Определение типа символа -- isalpha, isdigit и всё-всё-всё.

<string.h>

Читать маны. 

Обратить внимание на memcpy, memmove. Например, memmove позволяет переместить строки, накладывающиеся друг на друга в памяти.


\paragraph{Домашнее задание}

wc, sort. Написать комбинацию этих двух программ.

Сортировать нужно строки, в конце которых стоит '\textbackslash{}n', а остальные символы могут быть произвольными (даже '\textbackslash{}0'). Строки сортировать лексикографически, результат складывать в другой файл.

Можно читать весь файл в память, но нельзя отводить память под файл, узнав его размер fstat'ом (то есть нужно использовать realloc).

Вывести число строк, слов и символов в файле. Слова разделены пробельными символами, пустая строка есть строка.

Нельзя использовать безопасную функцию считывания строки. Нельзя использовать string.h.

\paragraph{Ликбез}

man man

apropos -- поиск по заголовкам man'ов.

Секции man:

1 -- системные утилиты и программы.

2 -- системные вызовы.

3 -- библиотечные функции.

4 -- специальные файлы (обычно из /dev).

5 -- описание конфигов.

6 -- программы для Xorg.

7 -- философская (что такое, зачем вообще нужно; напр., man 7 ip -- описание IP, man 7 signal -- описание всех сигналов ОС).

\section{10.03.2016}
\paragraph{Short Task 4}

Реализовать макрос побитовой распечатки в виде отдельного s-файла, написанный на ассемблере.
Только long.
print\_bits(long int number, char* str). ВЕСЬ ОТВЕТ (с красивостями) писать в str. str хорошая, выделена вне, в неё всё влезает.
\paragraph{Требования к оформлению файлов.}

\begin{enumerate}
\itemФайл именовать латиницей.
\itemВсе файлы именовать маленькими буквами (snake case, короче).
\itemЦифра в имени может быть лишь в конце.
\itemЗАГЛАВНЫМИ БУКВАМИ или С Большой Буквы нужно писать Readme, Makefile, Release\_notes.
\itemВ README писать информацию, относящуюся к данному каталогу.
\itemПримеры работы принято класть в каталог examples.
\end{enumerate}
\paragraph{Makefile}

Набор команд по приведению программы из исходников в рабочее состояние.

make будет компилировать с учётом этого файла. Зачастую используется GNU Make.

CC=gcc говорит, чтобы .c собирались gcc.

CFLAGS=-Wall -ansi -pedantic -- флаги компиляции.

PROGRAMS= converter tests -- имена программ.

Компиляция осуществляется по целям. По дефолту цель all

all: \$(programs) -- правило. Левая часть правила зависит от правой части. Левая часть должна либо отсутствовать, либо быть старее, чем правая. 
(эти части -- файлы. Если всё собрано, то ничего как бы и не запускается.)

Образуется дерево зависимостей файлов от других файлов. Потом make начинает собирать дерево от листьев. Таким образом, если изменился только один файл, можно пересобрать только путь из этой вершины до корня.

converter: converter.o xz.o

[табуляция]	\$(CC) \$(CFLAGS) -o converter ... 
Оптимизированно: \$(CC)\$(CFLAGS) -o \$@ \$\tac

\%.o : \%.c -- шаблонное правило. \% -- шаблон в смысле правила.

[tab] \$(CC) \$(CFLAGS) -c 

[tab] \$\tac -- всё, что стоит после двоеточия. \$< -- хз что.

Цель .PHONY: doc -- делает все цели, указанные справа, устаревшими. Надобно для работы с каталогами (если меняем файл в каталоге, каталог не меняется, make не видит изменения).

Цель clean: -- приводит каталог к тому состоянию, которое было до сборки.

Цель install: -- действия, необходимые для того, чтобы развернуть код в место его будущей работы.

Переменная PREFIX=\$(HOME)/bin. Так обычно указывают, куда развёртывать программу.

При компиляции можно явно указать цель (иначе выполняется первая цель в Makefile). Напр., make clean.

Если хочется вызвать make из подкаталога, то \$(make) -c doc 

SOURCES = \$(wildcard *.c) -- образец того, что нужно взять из файловой системы.

OBJS=\$(patsubst \%.c,\%.o, \$(sources))

little\_task\_\%: little\_task\_\%.o

В makefile есть директива include, напр. include config. Она утаскивает всё из config.ac. Есть ещё automake.

Директива gcc -M заставляет сгенерить файл зависимостей в виде makefile.

\section{11.03.16}
\paragraph{Низкоуровневый IO}
Файлы в UNIX -- абстракция. Их даже может не быть в файловой системе. Для них определены операции 
\begin{enumerate}
\item read. Считать с такого-то адреса в такой-то адрес. Этим управляет ОС. Операция read -- своего рода запрос. Она не гарантирует выполнение. Может просто выйти и сказать, что прочитала столько-то, а дальше не удалось.
\item write. То же самое, только на чтение.

Если открыть один и тот же файл дважды, он будет считаться как два файла. Операции с разными файловыми дескрипторами будут не синхронизированы. 
\item ioctl. Управление устройством (например, если файл на самом деле -- терминал, характеризующийся шириной, управляющими клавишами и т. д.
\item fcntl. Нужен для установки разных штук, в основном блокировок. Блокировать можно файл, можно диапазон. Тогда никакая другая программа не сможет обращаться. Не у всех видов файлов (например, файл клавиатуры) можно блокировать диапазоню
\item lseek. Сдвигает файловый курсор, если это возможно.

Когда файл открывается, в системе заводится таблица открытых файлов процесса. Там всегда (в нормальном состоянии, если ничего специально не делать) лежат три строчки:

0. stdin

1. stdout

2. stderr

Каждый открытый файл добавляет свою строчку. fclose стирает строчку
Таблица имеет фиксированный размер, определяемый ОС. Таким образом, есть ограничение на количество открытых файлов процесса. Можно навесить принудительное ограничение. 
ulimit -a выводит все ограничения.
\item int dup(int fd); Смотрит fd строчку таблицы, ищет свободную и копирует fd туда, возвращая номер, куда скопировал. Если свободной нет, возвращает -1 и выставляет errno.
Например, если скопировать что-то на нулевую строчку, то считывание из stdin на самом деле будет считывать из файла.
\item int dup2(int fd\_what, int nek\_place)
Если обращаемся в каком-то месте к неоткрытому файлу (пустой строчке), то ошибка. Если открыть дважды один и тот же файл, строчки будут разные.
FILE* fdopen(int fd, ) fd -- файловый дескриптор. Просто возвращает FILE*, привязанный к такому-то дескриптору.
\item int open(char* file\_name, mode\_t mode, perm\_t perms)
-1, если не открылось. 
perms опционален. Если не указано, используется umask или fmask.

Права можно выставть константами из <systypes.h>

mode: O\_RDONLY, O\_RDWR, O\_TRUNCATE (стереть всё содержимое файла), O\_APPEND(дописать), O\_WRONLY, O\_CREAT (создать файл), O\_LARGEFILE (lseek не работает, нужно использовать длинный lseek), O\_DIRECTORY, O\_SYNC (запрет на буферизацию на уровне ядра ОС), O\_ASYNC (можно использовать aio\_read, aio\_write, которые не ждут завершения операции, а продолжают выполнение программы; можно узнать, завершилась ли операция, через aio\_wait), O\_CLOEXEC (закрывать файл, когда переходим с одной программы на другую), O\_EXCL (запрет создать файл, если он уже открыт).

\end{enumerate}

\section{17.03.16}
\paragraph{Параметры командной строки}
./prog a "b c" d

int main(int argc, char** argv, char** argp)

argc = 4

argv: "./prog" "a" "b c" "d" NULL

argp: "NAME=значение"

getenv -- поиск переменной и получение значения.

setenv -- выставить значение.

getopt, getopt\_long из <getopt.h> -- красиво получать параметры командной строки вида -d или --version.

Принято иметь -h или --help, -v или --version.

Version -- трёхчисельный номер. Последняя -- незначительные изменения, средняя -- изменения, затрагивающие API, первая -- изменения, затрагиващие концепцию програмы и значительно меняющие API.

getopt предполагает, что будет вызываться многократно и утягивать аргументы по порядку. Выставляет optind -- текущий параметр.

switch(optind)
{
case 'h':
напечатать help;
break;
...

case 'f':
file\_name = optarg;
break;
case '?':
передан какой-то левый параметр;
break;
}
\paragraph{Короткое задание 5}
Дописать разбор параметров getopt'ом. Нужен help и version. Сделать сообщения в духе: распарсил строку, буду конвертировать оттуда туда, конвертирую, сконвертировал.

В отдельное задание.
\paragraph{typedef}
typedef int Matrix[3][3];

Аналогия: int my\_ints[3][3] -- так описывается переменная.

Matrix *m;

Matrix ma[2];

m = ma;

m++;

*m = 10;

10 запишется в элемент с номером [0][0].

*m = m[0] = 0[m]

Арифметика с указателями производится кратно размеру объекту, на которое 
указывает.

typedef int** Matrix; -- совершенно другое. Массив указателей. Сдвиг на int*, а раньше на 9 интов.

Теоретически куски int* могут быть в разных участках памяти.

\paragraph{Порождение процессов}
pid\_t, описанный в <unistd.h>

Процесс делается двумя вызовами: clone и fork.

pid\_t fork();

Делает процесс-сын. Процесс-сын думает, что он на самом деле выполнялся с самого начала так же, как родитель. С его точки зрения fork возвращает 0, родителю возвращается pid сына. Если процесс не создался, возвращает -1.

Если нужно запустить другой процесс, копируем себя и меняем тело процесса.

Короче, fork делает полную копию выполняемой программы, а различить их можно значением, возвращаемым fork.

getpid -- свой pid. getppid -- pid родителя.

Если родитель исчез, его родителем назначается процесс 1. У процесса 1 родитель 0, 0 -- это ядро.

execve, execvp, execlp, execll -- замена тела программы.

execlp(char* path, char* argv\_0, ..., NULL). l for list.
execlv(char* path, char** v). v for vector.

pid\_t wait(int* status) -- ждёт завершения первого попавшегося сыновьего процесса, выдаёт pid завершившегося сына. status -- код возврата и какая-то служебная информация (2 байта под статус, остальные два -- как завершился процесс). В syswait описаны макросы, которыми можно разбирать эти результаты.

\paragraph{Где ищутся исполняемые файлы?}
Есть переменная окружения PATH. Напр., PATH=/bin;/usr/bin;/usr/sbin. При попытке запуски программы каталоги из PATH обходятся по порядку, и если исполняемый файл с таким-то именем найден, он запускается. Например, если ls найден в /usr/bin, неявно вызывается /usr/bin/ls.

\section{18.03.16}
\paragraph{Неименованные каналы}
int pipe(int fds[2]);

Предназначены для общения родственных (имеющих общего предка) процессов.
В ядре заводится буфер FIFO ограниченного размера. В таблице открытых файлов заводятся две записи, которые ведут внутрь ядра. К этим записям применимы read и write.

[0] -- вход, [1] -- выход. Возвращает через fds* присвоенные файловые дескрипторы. Возвращает 0, если всё хорошо, -1, если плохо.

При fork таблица открытых файлов наследуется.

Проблема: при обращении из разных источников никоим образом не синхронизируются операции считывания-записи.

При заполнении буфера write завершится только при освобождении буфера или уничтожении буфера.

При пустом буфере read завершится, только когда данные запишут.

Запись в pipe атомарная. Пишутся всегда какие-то куски. Например, за один write пишется 500 символов, если одновременно попытаться записать 403 и 505 символов, то будут значимые куски 500, 5, 403, разбросанные произвольным образом.

->| | -- запись

  | |

->| |

  | |

<-| | -- чтение

Если у процесса закрылся последний pipe на запись, всем читающим присылается  SIGPIPE.

Если же последняя стрелка на запись удалилась, то все стрелки на считывание получают EOF.

\section{24.03.16}
\paragraph{Длинное задание 2}
less
Должна узнавать ширину, высоту терминала, показывать текст, скроллить. Никаких ncurses! read, читающий из терминала, поможет отловить нажатия клавиш. Терминал нужно открыть в non-canonical mode (см. пример в примерах).
Весь файл с текстом можно читать в память. Стрелочки двигают на один символ. Если дошли до конца самой длинной строки, не крутить дальше.
less -n (слева нужно указывать номера строк типа 1: ...) имя\_файла
Можно использовать безопасную функцию считывания строки.

less > foo -- нехорошо. isatty()

Выход по q или ctrl+c.
man tty\_ioctl

Дедлайн через две недели.

\paragraph{Сигналы}
kill(pid\_t pid, int sig\_num)
-1, если не послалось, 0, если хорошо.

Все процессы в UNIX по группам. -1 -- всем процессам с id > 1. 0 -- все процессы с той же группой. -n -- всем процессам с группой n. n -- процессу с номером n.

man 7 signal -- общая информация о сигналах. 

kill -- убить.
abort -- убить с дампом памяти.
Игнорировать.
Остановиться.
Продолжить выполнение.
Для всех сигналов, кроме SIGKILL (убить просто совсем нафиг) и SIGSTOP, можно переопределить действия.
SIGUSR1, SIGUSR2 генерируют программы программистов (например, задание перечитать конфигурационный файл).
Сигналы имеют свойство слипаться, т. е. два SIGUSR1, посланные подряд, могут считаться за один. 
Сигналы реального времени тоже шлёт программист, они не слипаются, но реализованы сложнее, работают медленнее.

\begin{enumerate}
\item SIGINT -- ctrl+c в canonical mode -- когда хотим завершить программу.
\item SIGTSTP -- ctrl+z -- предполагается. что программа будет остановлена.
\item SGIPIPE -- см. ранее.
\item SIGCHLD -- приходит, когда сыновний процесс завершился или остановился.
\item SIGILL -- попытались использовать инструкцию от другой архитектуры процессора.
\item SIGBUS -- ошибка на шине памяти.
\item SIGSEGV -- ошибка сегментации.
\item SIGALRM -- когда сработал таймер, выставленный функцией alarm.
\item SIGABRT -- данный процесс нужно убить с дампом памяти.
\item SIGCONT -- возобновить работу.
\end{enumerate}

typedef void (*sig\_handler\_t)(int sig);
sig\_handler\_t signal(int signal, sig\_handler\_t handler);
Возвращает старый обработчик.
Для совместимости со старыми версиями функция-обработчик при своём вызове должна зарегистрировать себя как обработчик.

sigaction -- современный способ делать то же самое.

typedef void(sig\_handler\_t)(int sig, sig\_info\_t info)

Можно установить сигнальную маску системным вызовом sigprocmask (на время обработки данного сигнала запретить другие сигналы, кроме SIGKILL и SIGSTOP), передать дополнительные параметры и проч.

pause() приостанавливает процесс до прихода первого попавшегося сигнала.

sigwaitinfo(...) выставляет info.

Чтобы не кешировал и не менял адрес переменной в памяти, а то в обработчике и основной программе были бы (возможно) разные штуки. К тому же, printf, работающие одновременно, могут начать одновременно писать в буфер.

volatile int a; 
void handler(int sig)
{
a = 15; printf("bbbb"); 
}
int main() {
if (a == 10) {
print("win");
}
}

// По хорошему тут нужен write, который атомарен.
\paragraph{Короткое задание 6}
Программа, которая пишет pid первых десяти процессов, которые прислали ей сигнал. Дедлайн -- завтра.

\section{25.03.16}
\paragraph{Короткое задание 7}
Та же штука, что и на семинаре, для дерева процессов (со внуками). Можно использовать только один канал. Дерево см. на картинке (?).
Рекомендуется использовать sigaction (для маскирования сигналов). По хорошему, нужно узнать сигналы реального времени.

\section{08.04.16}
\paragraph{Именованный канал}
Позволяет передавать данные между не родственными процессами.

mkfifo(const char* file\_name)

В файловой системе заводится специальный файл, который на самом деле отображается в оперативную память. После этот файл можно просто открыть.

Процесс при открытии файла на запись повисает до тех пор, пока кто-нибудь не откроет его на чтение.

Сокеты семейства PF\_UNIX -- то же самое, только с ними работают, как с сетью.

\paragraph{Потоки/threads}
Если при fork создаётся копия сегмента данных, состояния регистров, стека, то у потока сегмент данных не копируется. Это означает, что глобальные переменные у них одни и те же, и каждый может их менять. Потенциально, переменные, описанные в куче, тоже общие, т. к. другие потоки могут до них добраться (знать, где лежат данные, будет только один поток).

Системный вызов clone -- единственный способ создать процесс. При одном наборе параметров получается fork(), при другом -- pthread\_create.

Библиотека <pthread.h>
Компилировать с ключом -pthread или -lpthread.

Процесс порождает внутри себя нити. pthread\_exit выходит. pthread\_join сливает обратно. 
Главная нить называется master\_thread. pthread\_detach позволяет отделить нить от главной 
pthread\_cancel из master-нити досрочно убивает порождённую нить.

Функции бывают потокобезопасные (thread-safe; не используют глобатьные переменные, по завершении работы всю свою память в куче убивают или возвращают как значение. Она не должна менять состояние между выводами (например, как делает rand()) и thread-unsafe (небезопасные). Последние обычно работают медленнее. В stdlib безопасные имеют обычно суффикс \_r.
Посему нужно либо использовать безопасные версии, либо заботиться, что функции будут выполняться строго последовательно.
pthread\_t thread1;
typedef void* (*thread\_body\_t)(void*);
int pthread\_create(pthread\_t *thread, const pthread\_...* attr, thread\_body\_t body, thread\_id, void* arg);

\paragraph{Mutex}
mutex имеет состояние locked или unlocked.
Любой процесс может заблокировать mutex, если он был разблокирован.
pthread\_mutex\_lock();
// критическая секция кода
pthread\_mutex\_unlock();
Процесс может заблокировать mutex. Другие процессы будут виснуть на попытке входа в mutex, пока первый процесс не разблокирует его.
pthread\_mutex\_trylock пытается заблокировать mutex, если он уже заблокирован, возвращается ошибка, если разблокирован, возвращается успех.
time\_lock блокирует на время, и даже если предыдущий процесс не вышел, по истечении времени mutex разблокируется.
pthread\_mutex\_init, pthread\_mutex\_destroy создаёт и уничтожает mutex соответственно. При уничтожении мьютекса все процессы, стоящие на нём, разблокируются.
\paragraph{Условные переменные(cond\_var)}
pthread\_cond\_init, pthread\_cond\_destroy
В критической секции можно манипулировать условными переменными.
pthread\_cond\_wait, pthread\_cond\_signal, pthread\_cond\_bcast
Процесс, пришедший к wait, немедленно разблокирует mutex, а сам процесс виснет на wait, пока кто-нибудь не вызовет signal или bcast ( причём необязательно из критической секции. Так, например, можно сделать барьер, чтобы ни один из потоков не пошёл дальше, пока все из них не дойдут до этого барьера.
signal разблокирует одного случайного, bcast -- всех.
\end{document}